load("./R/sysdata.rda")

#' Analysis of proteomics data
#'
#' This package implements several functions to analyze Affinity Purification data.
#' 
#' By default, it is configured to work with proteinGroups.txt files
#' generated by MaxQuant
#'
#'
#' @param df A dataframe containing protein intensities. By default, protein intensity column names start by "Intensity." 
#' (use parameter \code{Column_intensity_pattern} to change)
#' Columns might also include "Score" (for protein identification score),
#' "Gene.names" (for gene names), "Intensity" (for mean protein intensity), 
#' "iBAQ" (for mean iBAQ intensity) or "Mol..Weight..kDa."
#' (as expected after importing a proteinGroups.txt file generated by MaxQuant using read.csv ).
#' @param bait_gene_name The gene name of the bait
#' @param Column_gene_name df's column corresponding to gene names
#' @param Column_intensity_pattern Pattern (regular exrpression) used to identfy df's columns containing protein intensity values
#' @param N_rep number of iteration for the replacement of missing values
#' (if \code{Nrep}=0, missing values are not replaced)
#' @param bckg_bait Τhe name of the bait found in \code{bckg} (see below) or in df's names if \code{bckg} is not provided
#' @param bckg_ctrl Τhe name of the control background found in \code{bckg} (see below) or in df's names if \code{bckg} is not provided
#' @param bckg Vector of length equal to the number of protein intensity columns indicating which background a column refers to 
#' (containing either  \code{bckg_bait} or  \code{bckg_ctrl} )
#' @param time Vector of length equal to the number of protein intensity columns indicating experimental conditions  
#' (for instance time of stimulation)
#' @param bio Vector of length equal to the number of protein intensity columns indicating biological replicates
#' @param tech Vector of length equal to the number of protein intensity columns indicating technical replicates
#' @param preffix_time Preffix for experimental conditions in column names (i.e "t" if pattern is "_t300")
#' @param preffix_bio Preffix for biological replicates in column names (i.e "S" if pattern is "_S1")
#' @param preffix_tech Preffix for technical replicates in column names (i.e "R" if pattern is "_R3")
#' @param filter_time vector of experimental conditions to exclude from analysis
#' @param filter_bio vector of biological replicates to exclude from analysis
#' @param filter_tech vector of technical replicates to exclude from analysis
#'
#'
#' @return a object of class \code{Interactome}, i.e a list including the following elements :
#' \code{conditions} : a vector of experimental conditions; 
#' \code{names} : a vector of names (by default gene names are used); 
#' \code{p_val} : a list of vectors containing the p values associated to each experimental condition; 
#' \code{fold_change} : a list of vectors containing the fold change associated to each experimental condition; 
#' \code{...} : other variables
#'
#' @import dplyr
#' @import ggplot2
#' @import ggrepel
#' @import grid
#' @import stringr
#' 
#' @export
#'
#' @author Guillaume Voisinne
#'
#' @examples
#' 
#' #load data :
#' dir<- system.file("extdata", package = "InteRact")
#' path <- paste(dir,"/proteinGroups_Cbl.txt",sep="")
#' df <- read.csv(path, sep="\t", nrows=-1, fill=TRUE, na.strings="", dec=".")
#' 
#' res <- InteRact(df, bait_gene_name = "Cbl")
#' 
#' # Check which columns have been used along with their description
#' print.data.frame(res$cond)
#' 
#' # You now have an object of class \code{InteRactome} that you can plot
#' Interactome <- res$Interactome
#' plot(Interactome)
#' plot_volcanos(Interactome, show_plot = TRUE )
#' 
#' # and manipulate by filtering conditions :
#' Interactome <- filter_conditions(Interactome, Interactome$conditions[1] )
#' plot(Interactome)
#' 
#' #or by re-ordering its elements (proteins)
#' order_list <- get_order_discrete(Interactome)
#' Interactome <- order_interactome(Interactome, order_list$idx_order)
#' #Print Interactome by experimental condition :
#' plot_per_conditions(Interactome, idx_rows = min(30, order_list$Ndetect))
#' 
#' # You can identify columns and their description separately using \code{identify_conditions()}
#' cond <- identify_conditions(df, bckg_bait="Cbl")
#' print.data.frame(cond)
#' # and use it as parameters for function \code{InteRact()}
#' res <- InteRact(df, bait_gene_name = "Cbl", bckg=cond$bckg, time=cond$time, bio=cond$bio, tech=cond$tech)
#' 
#' # You can define your own default pattern for intensity columns :
#' pattern = "^iBAQ"
#' cond <- identify_conditions(df, bckg_bait="Cbl", Column_intensity_pattern = pattern))
#' # Let's check that these column contain numeric variables
#' sapply( grep(pattern,names(df)), function(x) typeof( df[, x] ) ) 
#' # Make sure to use the same pattern in function \code{InteRact()}
#' res <- InteRact(df, Column_intensity_pattern = pattern, bait_gene_name = "Cbl", bckg=cond$bckg, time=cond$time, bio=cond$bio, tech=cond$tech)
#' 

InteRact <- function(df,
                     Column_gene_name = "Gene.names",
                     bait_gene_name,
                     N_rep=10,
                     bckg_bait = bait_gene_name,
                     bckg_ctrl = "WT",
                     bckg = NULL,
                     time=NULL,
                     bio=NULL,
                     tech=NULL,
                     Column_intensity_pattern = "^Intensity.",
                     preffix_bio="S",
                     preffix_tech="R",
                     preffix_time="",
                     filter_time=NULL,
                     filter_bio=NULL,
                     filter_tech=NULL,
                     updateProgress = NULL
                     ){
  
  if( sum( sapply( grep(Column_intensity_pattern,names(df)), function(x) is.factor( df[, x] ) ) ) >0 ){
    stop("Some intensity columns are factors, try changing the decimal separator (most likely '.' or ',') used for importing the data")
  }
  
  df$gene_name <- sapply(df[[Column_gene_name]], function(x) strsplit(as.character(x),split=";")[[1]][1] )
  
  df<-filter_Proteins(df);
  df$Npep <- estimate_Npep(df)
  ibait <- which(df$gene_name == bait_gene_name);
  if(length(ibait)==0){
    stop(paste("Could not find bait '",bait_gene_name,"' in column '",Column_gene_name,"'", sep="")) 
  }
  
  # Identify conditions corresponding to intensity columns
  idx_col<-grep(Column_intensity_pattern,colnames(df))
  T_int <- df[ ,idx_col];
  col_I <- colnames(T_int)
  
  if( is.null(bckg) | is.null(time) | is.null(bio) | is.null(tech) ){
    cond <- identify_conditions(df, 
                                Column_intensity_pattern = Column_intensity_pattern, 
                                bckg_bait = bckg_bait, 
                                bckg_ctrl = bckg_ctrl,
                                preffix_time = preffix_time,
                                preffix_bio = preffix_bio, 
                                preffix_tech = preffix_tech )
  }
  else{
    cond <- dplyr::tibble(idx=seq_along(col_I), column=col_I, bckg, time, bio, tech)
  }
  

  # filter out some experimental conditions
  
  cond_filter <- cond
  idx_filter <- c( unlist( lapply(filter_time, function(x) l=which(cond$time==x) ) ) , 
                   unlist( lapply(filter_bio, function(x) l=which(cond$bio==x) ) ),
                   unlist( lapply(filter_tech, function(x) l=which(cond$tech==x) ) ) )
  
  if(!is.null(idx_filter) && length(idx_filter)>0 ){
    cond_filter <- cond[-idx_filter,] 
  }
  cat(idx_filter)
  
  #Normalize on median intensity across conditions
  
  T_int[T_int==0] <- NA;
  T_int_norm <- rescale_median(T_int);
  cat("Rescale median intensity across conditions\n")
  
  avg <- average_technical_replicates(T_int_norm, cond_filter)
  
  T_int_norm_mean = avg$Intensity
  idx_cond = avg$conditions
  
  # identify missing values
  
  log10_T_int_norm_mean <- log10(T_int_norm_mean);
  
  q <- quantile(log10_T_int_norm_mean[ , idx_cond$bckg==bckg_ctrl], na.rm=TRUE, probs=0.01);
  s <- mean( row_sd(log10_T_int_norm_mean[ ,idx_cond$bckg==bckg_ctrl]), na.rm=TRUE);
  
  log10_T_int_norm_mean_rep<-log10_T_int_norm_mean;
  
  # replace missing values
  
  if(N_rep>0){
    
    
    
    res <- vector("list", N_rep)
    names(res)<-paste( rep('Rep_',N_rep), 1:N_rep, sep="" )
    cat(paste("Replacemissing values and perform interactome analysis for",N_rep,"replicates\n",sep=" "))
    
    n_replace <- length(which(is.na(log10_T_int_norm_mean)));
    for(i in 1:N_rep){
      
      if (is.function(updateProgress)) {
        text <- paste0( i, "/", N_rep)
        updateProgress(value = i/N_rep*100, detail = text)
      }
      
      cat(paste("Nrep=",i,"\n",sep=""));
      log10_T_int_norm_mean_rep[is.na(log10_T_int_norm_mean)] <- rnorm( n_replace, mean=q, sd=s) 
      Tfinal <- 10^log10_T_int_norm_mean_rep
      rownames(Tfinal)<-df$gene_name
      
      res[[i]]<-analyse_interactome(df = Tfinal, bait_gene_name = bait_gene_name, ibait = ibait[[1]], Npep = df$Npep, 
                                   name_bait = bckg_bait, name_ctrl = bckg_ctrl,
                                   background = idx_cond$bckg, conditions = idx_cond$time, replicates = idx_cond$bio , 
                                   by_conditions = TRUE, log_transf = TRUE)
      res[[i]]$Protein.IDs <- df$Protein.IDs
      
    }
    
    res_mean = mean_analysis(res);
    
    
  }else{
    
    Tfinal <- 10^log10_T_int_norm_mean
    rownames(Tfinal)<-df$gene_name
    
    res_mean<-analyse_interactome(df = Tfinal, ibait = ibait[[1]], Npep = df$Npep,
                                 name_bait = bckg_bait, name_ctrl = bckg_ctrl,
                                 background = idx_cond$bckg, conditions = idx_cond$time, replicates = idx_cond$bio , 
                                 by_conditions = TRUE, log_transf = TRUE)
    res_mean$protein_ID <- df$Protein.IDs
  }
  
  res_mean <- global_analysis(res_mean);
  
  output=list( Interactome = res_mean, conditions = cond, conditions_filtered=cond_filter, mean_data = avg);
  
}


#' Identify conditions (background, time of stimulation, biological and technical replicates) 
#' from column names
#' @export
identify_conditions <- function(df,
                                Column_intensity_pattern = "^Intensity.",
                                bckg_bait,
                                bckg_ctrl = "WT",
                                preffix_bio="S",
                                preffix_tech="R",
                                preffix_time=""
                                ){
  idx_col<-grep(Column_intensity_pattern,colnames(df))
  T_int <- df[ ,idx_col];
  
  col_I <- colnames(T_int)
  
  s<-unlist( strsplit(unlist(strsplit(col_I, Column_intensity_pattern)), split="_") )
  
  rad_number<-unique( stringr::str_match(s, "([A-z]+)[0-9]")[,2] )
  rad_number[is.na(rad_number)] <- "";
  
  bckg<-vector("character",length(col_I));
  
  rad_no_number <- unique( stringr::str_match(s, "([A-z]+)")[,2] )
  rad_no_number[is.na(rad_no_number)] <- ""
  
  rad_unique <- lapply(rad_number, function(x)  unique(s[grep(x, s)] )) 
  rad_unique_length <- lapply(rad_number, function(x) length( unique(s[grep(x, s)] )) )
  rad_unique <- unlist( rad_unique[rad_unique_length==1] )
  
  rad<-rad_number[rad_unique_length>1]
  bckg_names <- union( setdiff(rad_no_number, rad_number), rad_unique)
  
  if( !is.element(preffix_bio, rad) ){
    warning(paste("preffix_bio '",preffix_bio,"' cannot be found in column names. Suggested preffixes are '", paste(rad, collapse="'; '"),"'",sep="" ))
  }
  if( !is.element(preffix_tech, rad) ){
    warning(paste("preffix_tech '",preffix_tech,"' cannot be found in column names. Suggested preffixes are '", paste(rad, collapse="'; '"),"'",sep="" ))
  }
  if( !is.element(preffix_time, rad) ){
    warning(paste("preffix_time '",preffix_time,"' cannot be found in column names. Suggested preffixes are '", paste(rad, collapse="'; '"),"'",sep="" ))
  }
  
  idx_bait <- grep(bckg_bait,col_I);
  if(length(idx_bait)>0){
    bckg[grep(bckg_bait,col_I)]<-bckg_bait;
  }else{
    warning(paste("Could not find '", bckg_bait,"' in column names. Suggested background names are '", paste(bckg_names, collapse="'; '"),"'",sep=""))
  }
  
  idx_ctrl <- grep(bckg_ctrl,col_I);
  if(length(idx_ctrl)>0){
    bckg[grep(bckg_ctrl,col_I)]<-bckg_ctrl;
  }else{
    warning(paste("Could not find '", bckg_ctrl,"' in column names. Suggested background names are '", paste(bckg_names, collapse="'; '"),"'",sep=""))
  }

  pattern_time <-paste("[._]",preffix_time,"([0-9]+)",sep="")
  time <- as.numeric(stringr::str_match(col_I, pattern_time)[,2] )

  pattern_bio <-paste("[._]",preffix_bio,"([0-9]+)",sep="")
  bio <- as.numeric( stringr::str_match(col_I, pattern_bio)[,2] )

  pattern_tech <-paste("[._]",preffix_tech,"([0-9]+)",sep="")
  tech <- as.numeric(stringr::str_match(col_I, pattern_tech)[,2] )
  
  cond <- dplyr::tibble(idx=seq_along(col_I), column=col_I, bckg, time, bio, tech)
  
}


#' Averaging of protein intensities over technical replicates
#' @param df A data frame of protein intensities
#' @param conditions A data frame containing the description of df's columns (i.e "idx", bckg", "time", "bio"  and "tech")
#' @return A list containing :
#' \code{Intensity}, a data frame of protein intensities averaged over technical replicates;
#' \code{conditions}, a data frame containing the description of Intensity's columns
#' @export
average_technical_replicates<-function(df, cond){
  
  cond_group <- dplyr::group_by(cond, bckg, time, bio)
  idx_cond <-  dplyr::summarize(cond_group, idx_all=list(idx))
  
  cond_name <- vector("character", dim(idx_cond)[1])
  df_mean = data.frame( matrix( NA, nrow = dim(df)[1], ncol=dim(idx_cond)[1] ) );
  
  for(j in 1:dim(idx_cond)[1]){
    cond_name[j] = paste( idx_cond$bckg[j], 't', idx_cond$time[j], 'rep', idx_cond$bio[j], sep="_");
    df_mean[[j]] <- rowMeans(df[ idx_cond$idx_all[[j]] ], na.rm=TRUE);
  }
  colnames(df_mean)=cond_name;
  
  output = list(Intensity=df_mean, conditions=idx_cond)
  
}

#' Filtering of a data frame using a threshold on protein identification score and 
#' gene names
#' @param df A data frame
#' @param min_score Threshold for protein identification score
#' @param Column_gene_name The name of df's column containing gene names
#' @return A filtered data frame 
#' @export
filter_Proteins <- function( df, min_score=0, Column_gene_name= "Gene.names", split_param=";"){

  idx_row = 1:dim(df)[1]
  if( "Score" %in% colnames(df)){
    idx_row= which( df$Score>min_score )
    df<-df[idx_row, ]
    cat("Data Filtered based on portein identification score\n")
  }else{
    warning("Column 'Score' not available : Data NOT Filtered based on portein identification score\n")
  }
  
  #Remove contaminants from dataset
  
  if( Column_gene_name %in% colnames(df)){
    
    df<-df[ - grep("KRT",toupper(df[[Column_gene_name]])), ]
    cat("Contaminant proteins discarded\n")
    
    idx_name <- which( nchar(as.character(df[[Column_gene_name]])) > 0  )
    if(length(idx_name)>0){
      df <- df[ idx_name, ]
      cat("Proteins with no gene name available discarded\n")
    }
    
  }else{
    warning(paste("Column gene_name '", Column_gene_name, "' not available",sep=""))
  }
  
  df$gene_name <- sapply(df[[Column_gene_name]], function(x) strsplit(as.character(x),split=split_param)[[1]][1] )
  
  output = df
}

#' @export
estimate_Npep <- function(df){
  
  if( "Intensity" %in% colnames(df) & "iBAQ" %in% colnames(df)){
    Npep <- round( as.numeric( as.character(df$Intensity))/as.numeric( as.character(df$iBAQ)) )
    cat("Number of theoretically observable peptides computed using iBAQ values\n")
  }else if("Mol..weight..kDa." %in% colnames(df) ){ 
    Npep <- df$Mol..weight..kDa.
    cat("Number of theoretically observable peptides unavailable : used MW instead\n")
  }else{
    Npep <- rep(1,dim(df)[1])
    cat("Number of theoretically observable peptides unavailable : set to 1\n")
  }
  output<-Npep
}

#' @export
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  
  library(grid)
  
  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)
  
  numPlots = length(plots)
  
  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                     ncol = cols, nrow = ceiling(numPlots/cols))
  }
  
  if (numPlots==1) {
    print(plots[[1]])
    
  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
    
    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
      
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}

#' @export
rescale_median <- function(df){
  df_out<-df;
  for (i in seq_along(df)){
    df_out[[i]] <- df[[i]]/median(df[[i]], na.rm=TRUE);
  }
  df_out
}

#' @export
row_sd <- function(df){
  output<-vector("double", dim(df)[1] )
  for(i in 1:dim(df)[1] ){
    output[i] <- sd(df[i,],na.rm=TRUE);
  }
  output
}

#' @export
row_ttest <- function(df, idx_group_1, idx_group_2, log_transf = TRUE){
  # compares groups of column values using a t-test for each row.
  # idx_group_1 : indexes of columns for group #1
  # idx_group_2 : indexes of columns for group #2
  # log_transf : if TRUE, performs the t-test on log transform data
  
  p_val <- rep(NaN,dim(df)[1]);
  fold_change <- rep(NaN,dim(df)[1]);
  output <- data.frame(p_val=p_val, fold_change=fold_change);
  
  if(log_transf){
    df_test<-log10(df)
  }else{
    df_test<-df
  }
  
  for(i in (1:dim(df)[1]) ){
    res<-try(t.test(df_test[i, idx_group_1], df_test[i, idx_group_2]), silent=TRUE)
    if(!inherits(res,"try-error")){
      p_val[i] <- res$p.value;
      fold_change[i] <- 10^(res$estimate[1]-res$estimate[2])
    }
  }
  output$p_val <- p_val;
  output$fold_change <- fold_change;
  output
  
}

#' @export
row_stoichio <- function(df, idx_group_1, idx_group_2, idx_bait, Npep){
  # compute stoichiometry of interaction for each row (protein).
  # idx_group_1 : indexes of columns for group #1 (OST bait)
  # idx_group_2 : indexes of columns for group #2 (WT)
  # idx_bait : row index for the bait
  # N_pep : vector with the number of theoretical observable peptides for each row (protein).
  
  stoichio <- rep(NaN,dim(df)[1]);
  
  xbait1<-df[idx_bait, idx_group_1]
  xbait2<-df[idx_bait, idx_group_2]
  
  for(i in (1:dim(df)[1]) ){
    x1<-df[i, idx_group_1]
    x2<-df[i, idx_group_2]
    stoichio[i] <- ( mean(x1)-mean(x2) ) / ( mean(xbait1)-mean(xbait2) )*Npep[idx_bait]/Npep[i]
  }
  stoichio
}

#' @export
analyse_interactome <- function( df, ibait, bait_gene_name, Npep, name_bait, name_ctrl, 
                                 background, conditions, replicates, 
                                 by_conditions = TRUE, log_transf = TRUE){
  # df :  dataframe of intensities. columns are experimental samples and rows are proteins
  # ibait : row index corresponding to the bait protein
  # Npep : vector containing the number of theoretically observable peptide per protein (same length as dim(df)[1])
  # name_bait : name of the bait as appearing in the background vector
  # name_ctrl : name of the control as appearing in the background vector
  # background : vector of background names for each experimental sample
  # conditions : vector of conditions for each each experimental sample
  # replicates : vector of biological replicates for each each experimental sample
  # by_conditions : if TRUE, comparison of intensities between background are performed for each experimental condition independantly
  # log_transf : if TRUE, comparison between groups are perform on log transformed protein intensities
  
  if(!by_conditions){
    conds<-rep(-1,length(background))
  }else{
    conds<-conditions
  }
  cond<-unique(conds);
  
  
  p_val <- vector("list",length(cond));
  fold_change <- vector("list",length(cond));
  stoichio <- vector("list",length(cond));
  names(p_val)<-as.character(cond);
  names(fold_change)<-as.character(cond);
  names(stoichio)<-as.character(cond);
  
  for( i in seq_along(cond) ){
    
    ttest <- row_ttest(df, 
                            which( background==name_bait & conds==cond[[i]]), 
                            which( background==name_ctrl & conds==cond[[i]]), 
                            log_transf = log_transf)
    p_val[[i]]<-ttest$p_val;
    fold_change[[i]]<-ttest$fold_change;
    stoichio[[i]] <- row_stoichio(df, 
                                  which( background==name_bait & conds==cond[[i]] ), 
                                  which( background==name_ctrl & conds==cond[[i]]), 
                                  idx_bait=ibait,
                                  Npep=Npep)
  }
  
  res = list(bait = bait_gene_name, 
             groups = paste(name_bait," vs ", name_ctrl, sep=""), 
             conditions= as.character(cond), 
             names=row.names(df), 
             p_val=p_val, 
             fold_change=fold_change, 
             stoichio=stoichio)
  
  class(res) <- 'InteRactome'
  
  return(res)
}

#' @export
mean_analysis <- function( res ){
  
  # average results from multiple call to function 'analyse_interactome'
  
  cat(paste("Averaging", length(res) ,"interactomes\n",sep=" ") )
  res_mean = res[[1]];
  
  for ( cond in seq_along(res_mean$conditions) ){
    p_val=vector("list",length(res));
    fold_change=vector("list",length(res));
    stoichio = vector("list",length(res));
    for ( i in seq_along(res)){
      p_val[[i]] <- res[[i]]$p_val[[cond]]
      fold_change[[i]] <- res[[i]]$fold_change[[cond]]
      stoichio[[i]] <- res[[i]]$stoichio[[cond]]
    }
    res_mean$p_val[[cond]] <- 10^( rowMeans( log10(do.call(cbind, p_val))) )
    #res_mean$sd_log10_p_val[[cond]] <- row_sd( log10(do.call(cbind, p_val))) 
    res_mean$fold_change[[cond]] <- 10^( rowMeans( log10(do.call(cbind, fold_change))) )
    res_mean$stoichio[[cond]] <- 10^ (rowMeans( log10(do.call(cbind, stoichio))) )
  }
  
  res_mean
  
}

#' @export
filter_conditions <- function (x, ...) {
  UseMethod("filter_conditions", x)
}

#' Filters conditions from an interactome
#' @export
filter_conditions.InteRactome <- function( res, conditions_to_filter_out ){
  
  idx_conditions <- which(is.element(res$conditions, conditions_to_filter_out ))
  res_filter<-res
  res_filter$conditions <- res$conditions[-idx_conditions]
    
  for(i in 1:length(res)){
    if( setequal( names(res[[i]]), res$conditions ) ){
      res_filter[[i]] <- res[[i]][-idx_conditions]
    }
  }
  if( "norm_stoichio" %in% names(res) ){
    res_filter <- global_analysis(res_filter)
  }
  return(res_filter)
}

#' @export
global_analysis <- function (x, ...) {
  UseMethod("global_analysis", x)
}

#' @export
global_analysis.InteRactome <- function( res ){
  
  res_int <- res;
  max_stoichio<- apply( do.call(cbind, res$stoichio), 1, function(x)  ifelse( sum(!is.na(x))>0, max(x,na.rm=TRUE),NaN) )
  max_stoichio[!is.finite(max_stoichio)]<-NaN
  res_int$max_stoichio <- max_stoichio
  
  matrix_fold_change<-do.call(cbind, res$fold_change)
  res_int$max_fold_change <- apply(matrix_fold_change , 1, function(x)  ifelse( sum(!is.na(x))>0, max(x,na.rm=TRUE),NaN) )
  
  matrix_p_val<-do.call(cbind, res$p_val)
  matrix_p_val[matrix_fold_change<1]<-NA # keep only p_values corresponding to a fold_change >1 
  res_int$min_p_val <- apply( matrix_p_val, 1, function(x)  ifelse( sum(!is.na(x))>0, min(x,na.rm=TRUE),NaN) )
  
  norm_stoichio = vector("list",length(res$conditions))
  names(norm_stoichio)<-res$conditions
  for ( i in seq_along(res$conditions) ){
    norm_stoichio[[i]] <- res$stoichio[[i]] / max_stoichio
  }
  res_int$norm_stoichio <- norm_stoichio
  
  output=res_int
  
}

#' @export
annotation_enrichment_analysis <- function( df, 
                                            idx_detect, 
                                            annotation_selected = c("Keywords", "Protein.families") , 
                                            names = df$Gene.names...primary.., organism = "mouse",
                                            updateProgress = NULL){
  # df : data frame with annotation data
  # idx_detect : indices of the subset of proteins in df for which the enrichment analysis is performed
  # against the background formed by all proteins in df
  # annotation_selected : set of annotation terms to consider. 
  #Annotations supported are stored in varaiable "supported_annotations:
  
  supported_annotations <- c( 
                             "Protein.families",  
                             "Pfam", 
                             "Keywords", 
                             "Reactome", 
                             "GO",
                             "Hallmark",
                             "KEGG",
                             "GO_molecular_function",
                             "GO_biological_process",
                             "GO_cellular_component",
                             "GOslim_molecular_function",
                             "GOslim_biological_process",
                             "GOslim_cellular_component")
  

  if(  is.null(df) | (sum(names(df) %in% supported_annotations) == 0) | (sum(annotation_selected %in% names(df)) != length(annotation_selected)) ){
    stop("Annotations not available. Import annotations first.")
  }else if ( length(annotation_selected) == 0) {
    stop("No annotations selected. Change selected annotations")
  }else if (sum(annotation_selected %in% supported_annotations) != length(annotation_selected)){
    stop("Annotations not supported. Change selected annotations")
  }
  
  cat("Perform annotation enrichment analysis...\n")
  
  #list annotation terms found in the dataset ------------------------------------------------
  
  df_int <- df
  
  if("Protein.families" %in% annotation_selected){
    df_int[["Protein.families"]] <- as.character(df_int[["Protein.families"]])
    for (i in 1:length(df_int[["Protein.families"]])){
      s <- strsplit(df_int[["Protein.families"]][i], split=", ")[[1]]
      s_develop <- s[1]
      if (length(s) > 1) {
        for (j in 2:length(s)){
          s_develop <- c(s_develop, paste(s_develop[length(s_develop)], s[j], sep=", "))
        }
      }
      df_int[["Protein.families"]][i] <- paste(s_develop, collapse="; ")
    }
  }
  
  annot_terms <- NULL
  annot_type <- NULL
  annot_names <- NULL
  
  for (annot_type_sel in annotation_selected){
    
      collapse_sep <- ";"
      if( annot_type_sel %in% c("Protein.families", "Keywords") ) collapse_sep <- "; "

      
      u_annot<-paste(unique(df_int[[annot_type_sel]]), collapse = collapse_sep)
      terms <- unique(strsplit(u_annot, split = collapse_sep)[[1]])
      
      annot_names_int <- terms
      if(annot_type_sel == "Reactome"){
        reactome <- switch(organism, "mouse" = reactome_mouse, "human" = reactome_human)
        annot_names_int <- paste(
                              reactome$Name[match(terms, reactome$ID)],
                              ", [",
                              reactome$ID[match(terms, reactome$ID)],
                              "]",
                              sep = "")
      }
      if(annot_type_sel == "Pfam"){
        pfam <- switch(organism, "mouse" = pfam_mouse, "human" = pfam_human)
        annot_names_int <- paste(
                                pfam$hmm.name[match(terms, pfam$hmm.acc)],
                                ", ",
                                pfam$type[match(terms, pfam$hmm.acc)],
                                ", [",
                                pfam$hmm.acc[match(terms, pfam$hmm.acc)],
                                "]",
                                sep = "")
      }
      
      annot_terms <- c(annot_terms,  terms)
      annot_type <- c(annot_type, rep(annot_type_sel, length(terms)))
      annot_names <- c(annot_names, annot_names_int)
      
  }
  
  df.annot <- data.frame(annot_terms = annot_terms, annot_type = annot_type, annot_names = annot_names)
  df.annot <- df.annot[which(df.annot$annot_terms != ""), ]

 
  
  
  # Compute Background -----------------------------------------------------------------------
  
  nodes_tot <- as.character(names);
  
  u_annot_nodes_collapse <- rep("", length(nodes_tot));
  idx_tot <- rep(0, length(nodes_tot));
  
  for ( i in 1:length(nodes_tot) ){
    s <- NULL
    for (annot_type in annotation_selected) {
      s <- c(s, as.character(df[[annot_type]][ i ]))
    }
    u_annot_nodes_collapse[i] <- paste(s, collapse = ";")
  }
  
  N_background = length(nodes_tot);
  
  n_annot <- dim(df.annot)[1]
  
  N_annot_background <- rep(0, n_annot);
  freq_annot_background <- rep(0, n_annot);
  nodes_annot_background <- rep("", n_annot);
  
  pb <- txtProgressBar(min = 0, max = 2*n_annot, style = 3)
  count<-0
  
  for ( k in 1:dim(df.annot)[1] ){
    
    idx_annot <- grep(df.annot$annot_terms[k], u_annot_nodes_collapse, fixed=TRUE)
    N_annot_background[k] = length(idx_annot);
    nodes_annot_background[k] = paste(nodes_tot[idx_annot], collapse=";")
    freq_annot_background[k] = N_annot_background[k]/N_background;
    
    count <- count +1
    setTxtProgressBar(pb, count)
    # progress bar
    if (is.function(updateProgress)) {
      text <- paste0( round(count/(2*n_annot)*100, 0), " %")
      updateProgress(value = count/(2*n_annot)*100, detail = text)
    }
  }
  
  N_annotation_test <- length(which(N_annot_background>0))
  
  # Perform enrichment test for each annotation ----------------------------------------------
  
  N_annot <- rep(0, n_annot);
  freq_annot <- rep(0, n_annot);
  nodes_annot <- rep("", n_annot);
  p_value <- rep(0, n_annot);
  fold_change <- rep(0, n_annot);
  p_value_adjust <- rep(0, n_annot);
  
  for(k in 1:n_annot ){
    
    idx_annot <- idx_detect[ grep(df.annot$annot_terms[k], u_annot_nodes_collapse[idx_detect],fixed=TRUE) ]
    N_annot[k]=length(idx_annot);
    N_sample = length(idx_detect);
    
    freq_annot[k] = N_annot[k]/N_sample;
    nodes_annot[k]=paste(nodes_tot[idx_annot], collapse=";")
    
    p_value[k] = 1-phyper(N_annot[k]-1, 
                          N_annot_background[k],  
                          N_background-N_annot_background[k],  
                          N_sample);
    
    fold_change[k] = freq_annot[k]/freq_annot_background[k];
    
    count <- count +1
    setTxtProgressBar(pb, count)
    # progress bar
    if (is.function(updateProgress)) {
      text <- paste0( round(count/(2*n_annot)*100, 0), " %")
      updateProgress(value = count/(2*n_annot)*100, detail = text)
    }
  }
  
  close(pb)
  
  idx_annot_exist <-  which(N_annot>0);
  p_value_adjust_fdr <- rep( 1,length(p_value) );
  p_value_adjust_bonferroni <- rep( 1,length(p_value) );
  p_value_adjust_bonferroni[idx_annot_exist] <- p.adjust(p_value[idx_annot_exist], method = "bonferroni");
  p_value_adjust_fdr[idx_annot_exist] <- p.adjust(p_value[idx_annot_exist], method = "fdr");
  
  df.annot.2 <- data.frame(
                  N_annot,
                  freq_annot,
                  fold_change, 
                  p_value, 
                  p_value_adjust_fdr,
                  nodes_annot,
                  p_value_adjust_bonferroni,
                  N_annot_background, 
                  freq_annot_background,
                  nodes_annot_background)
  
  df.annot<-cbind(df.annot, df.annot.2)
  
  df.annot <- df.annot[ order(df.annot$p_value, decreasing = FALSE), ]
  cat("Done.\n")
  
  return(df.annot)
}

#' @export
plot_annotation_results <- function(df, p_val_max=0.05, method_adjust_p_val = "fdr", fold_change_min =2, N_annot_min=2){
  
  if(length(df) == 0 ){
    stop("Empty input...")
  }else if( dim(df)[1] == 0){
    stop("Empty input...")
  }
    
  name_p_val <- switch(method_adjust_p_val,
                       "none" = "p_value",
                       "fdr" = "p_value_adjust_fdr",
                       "bonferroni" = "p_value_adjust_bonferroni")
  
  df$p_value_adjusted <- df[[name_p_val]]
  
  idx_filter <-  which(df$p_value_adjusted <= p_val_max & 
                       df$fold_change >= fold_change_min & 
                       df$N_annot >= N_annot_min)
  if(length(idx_filter) == 0){
    stop("No annotation left after filtering. You might want to change input parameters")
    return(NULL)
  }
  df_filter <- df[ idx_filter, ]
  df_filter <- df_filter[ order(df_filter$p_value, decreasing = TRUE), ]
  df_filter$order <- 1:dim(df_filter)[1]
  
  p <- ggplot( df_filter, aes(x=order, y=-log10(p_value_adjusted) )) + 
    theme(
      axis.text.y = element_text(size=14),
      axis.text.x = element_text(size=14, angle = 90, hjust = 1,vjust=0.5),
      axis.title.x = element_text(size=14)
    ) +
    scale_x_continuous(name = NULL, breaks=df_filter$order, labels=df_filter$annot_names) +
    scale_y_continuous(name = paste("-log10(",name_p_val,")",sep="")) +
    geom_col()+
    coord_flip()
  
  return(p)
  
}

#' @export
append_annotations <- function (x, ...) {
  UseMethod("append_annotations", x)
}

#' @export
append_annotations.InteRactome <- function( res, annotations=NULL, name_id = "Protein.IDs" ){
  
    res_int<-res
    
    n_annot <- 0
    for (annot_var in names(annotations)){
      n_annot <- n_annot + length(annotations[[annot_var]])
    }
    
    if( is.null(annotations) | n_annot == 0){
      warning("No annotations to append")
    }
    else{
      cat("Append annotation to interactome...\n")
      idx_match<-rep(NA,length(res$names))
      for(i in 1:length(res$names) ){
        idx_match[i] <- which(as.character(annotations[[name_id]]) == as.character(res[[name_id]][i]) )
      }
      
      for( var_names in setdiff(names(annotations), name_id) ){
        res_int[[var_names]] <- as.character(annotations[[var_names]][idx_match])
      }
      cat("Done.\n")
    }
    
    return(res_int)
    
}

#' @export
get_annotations <- function( data, name_id = "Protein.IDs", split_param = ";", organism = "mouse", updateProgress = NULL ){
# Get annotations from uniprot for a set of protein identifiers
# From a set of IDs, keep the first that correspond to a "reviewed" protein, 
# or by default the first ID of the set
# name_id : column containing the set of protein identifiers separated by "split_param"
# organism = c("mouse", "human")
  
  df_annot <- switch(organism, "mouse" = uniprot_data_mouse, "human" = uniprot_data_human)
  
  df<-NULL
  
  nodes_IDs<- as.character(data[[name_id]]);
  Nnodes<-length(nodes_IDs)
  
  if( length( strsplit( paste(nodes_IDs, collapse=" "), split = split_param, fixed = TRUE)[[1]] ) == 1){
    stop(paste("The split parameter '",split_param, "' was not detected in '", name_id,"' : Change split_param.", sep = "") )
  }
    
  nodes_ID<-rep("", Nnodes);
  imatch<-rep(NA, Nnodes);
  

  # create progress bar
  cat("Creating annotation table...\n")
  pb <- txtProgressBar(min = 0, max = Nnodes, style = 3)
  
  
  for (i in 1:Nnodes ){
    
    list_nodes_ID<- unique(strsplit(nodes_IDs[i], split=split_param, fixed = TRUE)[[1]]);
    for(j in 1:length(list_nodes_ID) ){
      nID_clean <- strsplit(list_nodes_ID[j], split="-")[[1]][1];
      idx_entry<-which(df_annot$Entry == nID_clean)
      if(length(idx_entry>0)) {
        
        if(is.na(imatch[i])){
          imatch[i]<-idx_entry;
        }
        
        if(df_annot$Status[idx_entry]=="reviewed"){
          imatch[i]<-idx_entry;
          break;
        }
        
      }
    }
    setTxtProgressBar(pb, i)
    
    if (is.function(updateProgress)) {
      text <- paste0( round(i/Nnodes*100, 0), " %")
      updateProgress(value = i/Nnodes*100, detail = text)
    }
    
  }
  close(pb)
  
  df<-df_annot[imatch, ]
  df <- cbind(data[[name_id]], df)
  names(df)[1] <- name_id
  
  names(df)[which(names(df) == "Cross.reference..Pfam.")]<-"Pfam"
  names(df)[which(names(df) == "Cross.reference..Reactome.")]<-"Reactome"
  names(df)[which(names(df) == "Gene.ontology..GO.")]<-"GO"
  
  cat("Done.\n")
  
  return(df)
  
}

#' @export
add_GO_data <- function(df, map_id = "Entry", GO_type="molecular_function", organism = "mouse", slim = FALSE, updateProgress = NULL){
# GO_type = "molecular_function", biological_process" or "cellular_component"
# organism = "mouse" or "human
# slim = TRUE or FALSE (use GO slim annotations)
  
  df_int <- df
  n <- length(df_int[[map_id]])
  
  GO_terms <- rep("", n)
  
  name_GOA <- paste("GOA_", organism, sep = "");
  if (slim) {
    name_GOA <- paste(name_GOA, "_slim", sep = "")
  }
  GOA <- get(name_GOA)
  
  idx_type <- as.vector(which(GOA$GO_type == GO_type))
  
  # create progress bar
  cat("Add GO annotation data...\n")
  pb <- txtProgressBar(min = 0, max = n, style = 3)
  
  for(i in 1:n){
    # progress bar
    if (is.function(updateProgress)) {
      text <- paste0( round(i/n*100, 0), " %")
      updateProgress(value = i/n*100, detail = text)
    }
    setTxtProgressBar(pb, i)
    
    idx_GO <- idx_type[ grep(df_int[[map_id]][i], GOA$DB_Object_ID[idx_type], fixed = TRUE) ]
    if(length(idx_GO) > 0){
      term <- paste(GOA$GO_name[idx_GO], " [", GOA$GO_ID[idx_GO], "]", sep = "")
      GO_terms[i] <- paste(as.character(unique(term)), collapse = ";")
    }
    
  }
  close(pb)
  
  name_annot <- "GO_"
  if( slim ) name_annot <- paste(name_annot, "slim_", sep ="")
  name_annot <- paste(name_annot, GO_type, sep= "")
  df_int[[name_annot]] <- GO_terms
  
  return(df_int)
}

#' @export
add_KEGG_data <- function(df, map_id = "Cross.reference..KEGG.", organism="mouse", updateProgress = NULL){
  
  df_int <- df
  n <- length(df_int[[map_id]])
  
  # Add KEGG data
  KEGG_pathways <- rep("", n)
  KEGG <- switch(organism, "mouse" = KEGG_mouse, "human" = KEGG_human)
  for(i in 1:n){
    # progress bar
    if (is.function(updateProgress)) {
      text <- paste0( round(i/n*100, 0), " %")
      updateProgress(value = i/n*100, detail = text)
    }
    
    if(!is.na(df_int[[map_id]][i])){
      if( nchar(as.character(df_int[[map_id]][i])) >0 ){
        idx_KEGG <- grep(df_int[[map_id]][i], as.character(KEGG$IDs), fixed = TRUE)
        pathways <- paste(KEGG$name[idx_KEGG]," [",KEGG$pathway[idx_KEGG],"]",sep="")
        KEGG_pathways[i] <- paste(as.character(pathways), collapse = ";")
      }
    }
    
  }
  df_int$KEGG <- KEGG_pathways
  
  return(df_int)
}

#' @export
add_Hallmark_data <- function(df, map_id="Gene.names...primary..", updateProgress = NULL){
  
  df_int <- df
  
  n <- length(df_int[[map_id]])
  hallmark_set <- rep("", n )
  
  
  # create progress bar
  cat("Add Hallmark annotation data...\n")
  pb <- txtProgressBar(min = 0, max = n, style = 3)
  
  for(i in 1:n){
    # progress bar
    if (is.function(updateProgress)) {
      text <- paste0( round(i/n*100, 0), " %")
      updateProgress(value = i/n*100, detail = text)
    }
    setTxtProgressBar(pb, i)
    idx_set <- NULL
    for(j in 1:dim(Hallmark)[1]){
      idx_in_geneset <- match(toupper(df_int[[map_id]][i]), strsplit(as.character(Hallmark$gene[j]), split=";")[[1]])
      if(!is.na(idx_in_geneset)){
        idx_set <- c(idx_set, j)
      }
    }
    hallmark_set[i] <- paste( as.character(Hallmark$name[idx_set]), collapse=";")
  }
  close(pb)
  
  df_int$Hallmark <- hallmark_set
  
  return(df_int)
}

#' @export
merge_proteome <- function (x, ...) {
  UseMethod("merge_proteome", x)
}

#' @export
merge_proteome.InteRactome <- function( res, Interactome_ID_name = "Entry" ){
  
      res_int <- res;
    
      gene_name_prot <- proteome_data$Gene.names;
    
      ibait <- match(res$bait, res$names)
      
      ######### Retrieve protein abundance and compute related quantities
      
      Copy_Number <- rep(0, length(res$names));
    
      for( i in 1:length(res$names) ){
        idx_prot <- which(gene_name_prot==as.character(res$names[i]));
        idx_ID_x <-  which(proteome_data$Protein.IDs.x==as.character(res$Protein.IDs[i]));
        idx_ID_y <-  which(proteome_data$Protein.IDs.y==as.character(res$Protein.IDs[i]));
        
        #idx_ID_x <-  grep(as.character(res[[Interactome_ID_name]][i]),  as.character(proteome_data$Protein.IDs.x), fixed=TRUE);
        #idx_ID_y <-  grep(as.character(res[[Interactome_ID_name]][i]),  as.character(proteome_data$Protein.IDs.y), fixed=TRUE);
        # 
        abund_x <- NA;
        abund_y <- NA;
        if( length(idx_ID_x)>0 ){ 
          abund_x <- proteome_data$mean.x[idx_ID_x] 
        }
        if( length(idx_ID_y)>0 ){ 
          abund_y <- proteome_data$mean.y[idx_ID_y] 
        }
        
        #Copy_Number[i] <- mean(c(abund_x, abund_y), na.rm = TRUE)
        
        if(length(idx_prot)>0){
         Copy_Number[i] = proteome_data$mean[ idx_prot[1] ];
        }else if( length(idx_ID_x)>0 || length(idx_ID_y)>0 ){
         Copy_Number[i] = mean( c(abund_x, abund_y), na.rm=TRUE);
        }else{
         Copy_Number[i] = NA;
        }
        
      }
      res_int$Copy_Number = Copy_Number
      res_int$stoch_abundance = Copy_Number / Copy_Number[ibait]
      
      #res_int$N_complex= Tsum$max_stoch*Copy_Number[ibait]
      #res_int$percentage_prey_in_complex = Tsum$max_stoch*Copy_Number[ibait]/Copy_Number;
      
      # Tsum$Perc_t_0 = Tsum$Stoch_t_0*Copy_Number[ibait]/Copy_Number;
      # Tsum$Perc_t_30 = Tsum$Stoch_t_30*Copy_Number[ibait]/Copy_Number;
      # Tsum$Perc_t_120 = Tsum$Stoch_t_120*Copy_Number[ibait]/Copy_Number;
      # Tsum$Perc_t_300 = Tsum$Stoch_t_300*Copy_Number[ibait]/Copy_Number;
      # Tsum$Perc_t_600 = Tsum$Stoch_t_600*Copy_Number[ibait]/Copy_Number;
  
      output=res_int
}

#' @export
plot_2D_stoichio <- function (x, ...) {
  UseMethod("plot_2D_stoichio", x)
}

#' @export
plot_2D_stoichio.InteRactome <- function( res, condition = "max", xlim=NULL, ylim=NULL, N_display=30){
  
  df<- data.frame( Y=log10(res$stoch_abundance), 
                   label_tot=res$names
                   )
  if(condition=="max"){
    df$X <- log10(res$max_stoichio)
    df$size <- res$max_fold_change
  }else if(condition %in% res$conditions){
    df$X <- log10(res$stoichio[[condition]])
    df$size <- res$fold_change[[condition]]
  }else{
    stop("Condition is not defined")
  }
  
  
  df<-df[1:min(N_display, dim(df)[1]), ]
  
  xc <- -0.5
  yc <- 0
  rc<-1
  
  ylow <- -3
  
  if(is.null(xlim) & is.null(ylim)){
    max_range <- max( max(df$X,na.rm=TRUE)-min(df$X,na.rm=TRUE),  max(df$Y,na.rm=TRUE)-ylow )
    center_x <- ( max(df$X,na.rm=TRUE)+min(df$X,na.rm=TRUE) )/2
    center_y <- (max(df$Y,na.rm=TRUE)+ylow)/2
  }else{
    max_range <- max( xlim[2] - xlim[1],  ylim[2] - ylim[1] )
    center_x <- ( xlim[2] + xlim[1] )/2
    center_y <- ( ylim[2] + ylim[1] )/2
  }
  xmin<-center_x - max_range/1.9
  xmax<-center_x + max_range/1.9
  ymin<-center_y - max_range/1.9
  ymax<-center_y + max_range/1.9
  
  ylow_plot <- max(ylow,ymin)
  
  df$size_prey <- log10(df$size)/max_range*20
  df$size_label <- unlist(lapply(log10(df$size), function(x) { ifelse(x>0.5, min(c(x,3)), 0.5) }))/max_range*20/3
  df$sat_max_fold_t0 <- rep(1,dim(df)[1])
  
  idx_plot <- which(df$X<=xmax & df$X>=xmin & df$Y<=ymax & df$Y>=ymin)
  df <- df[idx_plot, ]
  
  p<-ggplot(df,aes(x=X, y=Y,label=label_tot)) +
    theme(aspect.ratio=1) +
    scale_color_gradient2(midpoint=0,  low="blue", mid=rgb(0,0,0), high="red",  space = "Lab" )+
    geom_polygon(data=data.frame(x=c(ylow_plot,xmax,xmax),y=c(ylow_plot,ylow_plot,xmax)), mapping=aes(x=x, y=y),alpha=0.1,inherit.aes=FALSE) +
    annotate("path",
             x=xc+rc*cos(seq(0,2*pi,length.out=100)),
             y=yc+rc*sin(seq(0,2*pi,length.out=100)), color=rgb(0,0,0,0.5) ) +
    annotate("segment", x = ylow_plot, xend = xmax, y = ylow_plot, yend = xmax, colour = rgb(0,0,0,0.5) ) +
    annotate("segment", x = xmin, xend = xmax, y = ylow_plot, yend = ylow_plot, colour = rgb(0,0,0,0.5) , linetype = "dashed") +
    xlab("log10(Interaction Stoichiometry)") +
    ylab("log10(Abundance Stoichiometry)") +
    geom_point(mapping=aes(x=df$X,y=df$Y,color=df$sat_max_fold_t0), size=df$size_prey, alpha=0.2, stroke=0, inherit.aes = FALSE, show.legend = FALSE)+
    coord_cartesian(xlim = c(xmin,xmax), ylim = c(ymin,ymax), expand = FALSE)+
    #geom_density_2d(colour=rgb(1,0,0),size=0.5) +
    geom_text_repel(mapping=aes(x=df$X,y=df$Y,label=label_tot,color=df$sat_max_fold_t0), size=df$size_label,force=0.002, 
                    segment.size = 0.1,
                    min.segment.length = unit(0.15, "lines"), 
                    point.padding = NA, inherit.aes = FALSE, show.legend = FALSE, max.iter = 100000)
  return(p)
  #print(p)
  #output=p
}

#' @export
get_order_discrete <- function (x, ...) {
  UseMethod("get_order_discrete", x)
}

#' @export
get_order_discrete.InteRactome <- function( res , p_val_breaks=c(1,0.1,0.05,0.01), p_val_thresh = 0.01, fold_change_thresh = 1){
  
  p_val_breaks_order <- p_val_breaks[order(p_val_breaks, decreasing=TRUE)]
  min_p_val_discrete <- rep(1, length(res$min_p_val));
  
  for( i in 1:length(p_val_breaks_order) ){
    min_p_val_discrete[res$max_fold_change>fold_change_thresh & res$min_p_val <= p_val_breaks_order[i] ]<-p_val_breaks_order[i];
  }
  
  Ndetect<-length(which( res$min_p_val<=p_val_thresh & res$max_fold_change>=fold_change_thresh) )
  idx_order<-order( min_p_val_discrete, 1/res$max_stoichio, decreasing =FALSE)
  
  output = list(idx_order=idx_order, Ndetect= Ndetect, min_p_val_discrete = min_p_val_discrete)
  return(output)
}

#' @export
order_interactome <- function (x, ...) {
  UseMethod("order_interactome", x)
}

#' @export
order_interactome.InteRactome <- function(res, idx_order){
  
  if(length(idx_order)!=length(res$names)){
    stop("Vector of ordering indexes does not have the proper length")
  }
  res_order<-res;
  for( var in setdiff( names(res), c("bait","groups","conditions") ) ){
    names_var <- names(res[[var]])
    if( length(names_var)>0 ){
      for(i in 1:length(names_var) ){
        res_order[[var]][[i]] <- res[[var]][[i]][idx_order]
      }
    }
    else{
      res_order[[var]] <- res[[var]][idx_order]
    }
  }
  output = res_order
}

#' @export
plot_Intensity_histogram <- function( I, I_rep, breaks=20, save_file=NULL){
    # plot histogram of intensities for all columns in two different datasets 
    # (1st dataset is in in black, 2nd dataset is in red)
    if(!is.null(save_file)){
      pdf( save_file, 4, 4 )
    }
    
    
    for( j in seq_along(I) ){
      h<-hist( I[[j]] , breaks=breaks, plot=FALSE);
      if(j>1){
        lines(h$mids,h$density,col=rgb(0,0,0,0.2));
      }else{
        plot(h$mids, h$density, type="l",col=rgb(0,0,0,0.2),ylim=c(0,1), xlim=range(I_rep));
      }
    }
    
    for( j in seq_along(I_rep) ){
      h<-hist( I_rep[[j]] , breaks=breaks, plot=FALSE);
      lines(h$mids,h$density,col=rgb(1,0,0,0.2));
    }
    
    if(!is.null(save_file)){
      dev.off()
    }
  
}

#' @export
plot_volcanos <- function (x, ...) {
  UseMethod("plot_volcanos", x)
}

#' @export
plot_volcanos.InteRactome <- function( res, 
                                       labels=NULL, 
                                       N_print=15, 
                                       conditions=NULL, 
                                       p_val_thresh=NULL, 
                                       fold_change_thresh=NULL, 
                                       save_file=NULL,
                                       xlim=NULL,
                                       ylim=NULL,
                                       show_plot=FALSE){
  if (is.null(labels)) labels=res$names
  if (is.null(conditions)) conditions=res$conditions
    
  plist <- vector("list",length(conditions));
  
  ymax <- -log10(min(do.call(cbind,res$p_val)))
  xmax <- max(abs(log10(do.call(cbind,res$fold_change))))
  
  x1 <- log10(fold_change_thresh)
  x2 <- xmax
  y1 <- -log10(p_val_thresh)
  y2 <- ymax
  
  if(!is.null(xlim) & !is.null(ylim)){
    xrange <- xlim
    yrange <- ylim
  }else{
    xrange <- c(-xmax,xmax)
    yrange <- c(0,ymax)
  }
  
  
  for( i in seq_along(conditions) ){
    
    df <- data.frame(p_val=res$p_val[[conditions[i]]], 
                     fold_change= res$fold_change[[conditions[i]]], 
                     names=labels)
    df$X <- log10(df$fold_change)
    df$Y <- -log10(df$p_val)
    score_print <- rep(0, dim(df)[1])
    
    if(!is.null(p_val_thresh) & !is.null(fold_change_thresh)){
      is_above_thresh <- rep(0, dim(df)[1])
      is_in_frame <- rep(0, dim(df)[1])
      is_above_thresh[ which(df$p_val <= p_val_thresh & df$fold_change >= fold_change_thresh ) ] <- 1
      is_in_frame[ which(df$X >= xrange[1] & df$X <= xrange[2] & df$Y >= yrange[1] & df$Y <= yrange[2]) ] <- 1
      score_print<- is_above_thresh + is_in_frame
      score_print[is_in_frame==0]<-0
      N_show <- min(N_print, sum(score_print>0))
      if( N_show>0 ){
        idx_print <- order(score_print, df$fold_change, decreasing = TRUE)[ 1 : N_show ]
      }else{
        idx_print <- NULL
      }
    }else{
      if( N_print>0 ){
        idx_print <- order(df$fold_change, decreasing = TRUE)[ 1:N_print ]
      }else{
        idx_print <- NULL
      }
    }
    
    df$label_color <- as.factor(score_print)
    
      
    plist[[i]] <- ggplot( df , aes(x=X, y=Y ) ) +
      coord_cartesian(xlim = xrange, ylim = yrange, expand = FALSE) +
      #scale_y_continuous(limits=c(0,ymax)) +
      #scale_x_continuous(limits=c(-xmax,xmax)) +
      ggtitle(conditions[i])
      
    
    if(!is.null(p_val_thresh) & !is.null(fold_change_thresh)){
      plist[[i]] <- plist[[i]] +
        geom_polygon(data=data.frame(x=c(x1,x2,x2,x1),y=c(y1,y1,y2,y2)), mapping=aes(x=x, y=y),alpha=0.1,inherit.aes=FALSE) +
        annotate("segment", x = -x2, xend = x2, y = y1, yend = y1, colour = rgb(1,0,0,0.5) ) +
        annotate("segment", x = -x1, xend = -x1, y = 0, yend = y2, colour = rgb(1,0,0,0.5) ) +
        annotate("segment", x = x1, xend = x1, y = 0, yend = y2, colour = rgb(1,0,0,0.5) )
    }
    
    plist[[i]] <- plist[[i]] + 
      geom_point(alpha=0.2) +
      geom_text_repel(data=df[idx_print, ],
                      aes(label = names, colour=label_color), size=5) +
      scale_color_manual(values = c("0" = "black", "1" = "black", "2" = "red"), guide=FALSE) +
      theme(legend.position="none")
    
  }
  
  if(show_plot){
    layout <- matrix(1:length(conditions), nrow = 1, byrow = TRUE)
    multiplot(plotlist = plist, layout = layout)
  }
  if( length(save_file)>0 ){
    pdf( save_file, 4*length(conditions), 4 )
    layout <- matrix(1:length(conditions), nrow = 1, byrow = TRUE)
    multiplot(plotlist = plist, layout = layout)
    dev.off()
  }
  
  return(plist)
}

#' @export
plot <- function (x, ...) {
  UseMethod("plot", x)
}

#' @export
plot.InteRactome <- function(x, 
                             p_val_breaks=c(1,0.1,0.05,0.01), 
                             p_val_thresh = 0.01,
                             fold_change_thresh=1,
                             Nmax=30, 
                             size_var="norm_stoichio", 
                             size_range=c(0,1), 
                             save_file=NULL ){
  order_list <- get_order_discrete(x, p_val_breaks, p_val_thresh, fold_change_thresh )
  Interactome_order <- order_interactome(x, order_list$idx_order)
  plot_per_conditions(Interactome_order, 
                      idx_rows = min(Nmax, order_list$Ndetect), 
                      size_var=size_var, 
                      size_range=size_range, 
                      color_var="p_val", 
                      color_breaks=p_val_breaks, 
                      save_file=save_file )
}

#' @export
plot_per_conditions <- function (x, ...) {
  UseMethod("plot_per_conditions", x)
}

#' @export
plot_per_conditions.InteRactome <- function( res, 
                                 idx_rows=1:20,
                                 size_var="norm_stoichio",
                                 size_range=c(0,1),
                                 color_var="p_val", 
                                 color_breaks=c(1,0.1,0.05,0.01), 
                                 #color_values=rgb(t(col2rgb(c("black", "blue","purple","red")))/255),
                                 color_default = 1,
                                 save_file=NULL,
                                 show_plot=TRUE,
                                 plot_width=3.25,
                                 plot_height=length(idx_rows)/(plot_width+1) + 1 ){
  
  if(length(idx_rows)==1){
    idx_rows<-1:idx_rows
  }
  
  M<-do.call(cbind, res[[size_var]])
  M1<-do.call(cbind, res[[color_var]])
    
  row.names(M) <- unlist(lapply(res$names, function(x) substr(x,1,min(8,nchar(x))) ) )
  Mcol<-M
  Mcol[!is.null(M)]<-color_default
  
   if(!is.null(color_var)){
     idx_order_col <- order(color_breaks, decreasing = TRUE);
     for(i in seq_along(color_breaks)){
       Mcol[M1<color_breaks[idx_order_col[i]]]<-color_breaks[idx_order_col[i]]
     }
   }
  
  p<-dot_plot( as.matrix(M[idx_rows, ]), 
               as.matrix(Mcol[idx_rows,]), 
               title = res$groups,
               size_var = size_var, 
               size_range=size_range,
               color_var=color_var)
  
  if(show_plot){
    print(p)
  }
  
  if(!is.null(save_file)){
    pdf(save_file, plot_width, plot_height)
    print(p)
    dev.off()
  }
  
  return(p)
  
}

#' @export
dot_plot <- function(Dot_Size, 
                     Dot_Color=NULL, 
                     title="Dot Plot", 
                     size_range=range(Dot_Size) , 
                     size_var ="size", 
                     color_var="color"){
  
  # Dot_Size: matrix of dot size
  
  M<-Dot_Size
  Mcol <- Dot_Color
  
  ylabels <- row.names(M)
  if(length(ylabels)==0){
    ylabels <- 1:dim(M)[1]
  }
  
  xlabels <- colnames(M)
  if(length(xlabels)==0){
    xlabels <- 1:dim(M)[2]
  }
  
  xpos <- vector("list", dim(M)[2] );
  ypos <- vector("list", dim(M)[2] );
  size <- vector("list", dim(M)[2] );
  if(length(Dot_Color)>0){
    if( sum(dim(M) != dim(M))==0 ){
      color <- vector("list", dim(M)[2] );
    }else{
      stop("Dimensions of size and color matrix do not match")
    }
  }
  
  #pos <- 1+dim(M)[1] - ( 1:dim(M)[1] )
  pos <-  - ( 1:dim(M)[1] )
  
  for( k in 1:dim(M)[2] ){
    xpos[[k]] <- rep(k, dim(M)[1] )
    ypos[[k]] <- pos
    size[[k]] <- as.numeric(M[,k]);
    if(length(Dot_Color)>0){
      color[[k]] <- Mcol[,k];
    }
  }
  
  df<-data.frame( xpos=unlist(xpos), ypos=unlist(ypos), size=unlist(size) );
  if(length(Dot_Color)>0){
    df$color = unlist(color)
  }else{
    df$color = rep( 1, dim(df)[1] )
  }
  
  df$color<-as.factor(df$color)
  
  unique_col <- unique(df$color);
  size_label_y <- max(6, 16 - (dim(M)[1] %/% 10)*1.5 )
  
  p <- ggplot(df, aes(x=xpos, y=ypos, size=size, col=color ) ) +
    theme(#plot.margin=unit(c(0.2,0,0,0), "cm"),
      plot.title = element_text(size=12),
      axis.text.y= element_text(size=size_label_y), 
      axis.text.x = element_text(size=16, angle = 90, hjust = 1,vjust=0.5) ) +
    ggtitle(title)+
    scale_color_manual( values=c( "red", "purple",  "blue", "black" ) , name=color_var) +
    scale_radius(limits=size_range, name=size_var) +
    #scale_colour_manual(values=setNames(unique_col, c( "red", "purple",  "blue", "black" ) )) +
    xlab("") +
    ylab("") +
    scale_x_continuous(breaks=1:dim(M)[2],
                       limits=c(0.5, dim(M)[2]+0.5),
                       labels=xlabels) +
    scale_y_continuous(breaks=pos,
                       #limits= -c(0.25, dim(M)[1]+0.75),
                       limits= -c(dim(M)[1]+0.75, 0.25 ),
                       labels=ylabels) +
    geom_point(alpha=0.5, show.legend = TRUE)
  
  return(p)
  
}

#' @export
summary_table <- function (x, ...) {
  UseMethod("summary_table", x)
}

#' @export
summary_table.InteRactome <- function(res, add_columns = NULL){
  
  columns <- unique( c("names", add_columns) )
  #columns <- add_columns
  columns <- setdiff(columns, c("bait","groups","conditions"))
  
  df<-data.frame( bait=rep(res$bait, length(res$names)) )
  names_df<-"bait"
  idx<-1
  
  for( var in columns ){
    names_var <- names(res[[var]])
    if( length(names_var)>0 ){
      for(i in 1:length(names_var) ){
        idx<-c(idx,NaN)
        names_df<-c(names_df, paste(var,"_",names_var[i],sep=""))
        df<-cbind(df,res[[var]][[i]])
      }
    }
    else{
      idx<-c(idx,1)
      names_df<-c(names_df, var)
      df<-cbind(df,res[[var]])
    }
  }
  names(df)<-names_df
  df<-df[,order(idx)]
  
  return(df)
  
}



################################################### Example ###################################################

#data( proteinGroups, package="InteRact" )
#bait_gene_name = "Cbl"
#path_to_file = "~/Google_Drive/++Work/++Research/++Projects/Interactomes-New/ProteinGroups_ALL/Original_files/proteinGroups_Cbl.txt"
#T<-read.csv(path_to_file, header=TRUE, sep="\t", nrows=-1, quote="\"", fill=TRUE, na.strings="", dec=".")

#assign( "proteinGroups", T)
#save("proteinGroups", file= paste( "~/proteinGroups.Rdata",sep="") )

#Interactome <- InteRact(T, bait_gene_name = bait_gene_name)

#plot_volcanos(Interactome, show_plot = TRUE )

# save_dir=paste("~/Desktop/Interactome_", bait_gene_name, sep="")
# dir.create(save_dir, showWarnings = FALSE)
# unlink(paste(save_dir,"/*",sep=""))

# plot_volcanos(Interactome, save_file = paste(save_dir,"/volcano_plot.pdf",sep="") , show_plot = FALSE )
# 
# order_list <- get_order(Interactome)
# Interactome <- order_interactome(Interactome, order_list$idx_order)
# 
# plot_per_conditions(Interactome, idx_rows = min(30, order_list$Ndetect), save_file = paste(save_dir,"/norm_stoichio.pdf",sep="") )
# 
# # save interactome
# interactome_name=paste("Interactome_",bait_gene_name, sep="")
# assign( interactome_name, Interactome)
# save(list=interactome_name, file= paste( save_dir,"/Interactome_", bait_gene_name, ".Rdata",sep=""))

