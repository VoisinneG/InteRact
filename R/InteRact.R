load("./R/sysdata.rda")

#' Analysis of proteomics data
#'
#' This package implements several functions to analyze Affinity Purification data.
#' 
#' By default, it is configured to work with proteinGroups.txt files
#' generated by MaxQuant
#'
#'
#' @param df A dataframe containing protein intensities. By default, protein intensity column names start by "Intensity." 
#' (use parameter \code{Column_intensity_pattern} to change)
#' Columns might also include "Score" (for protein identification score),
#' "Gene.names" (for gene names), "Intensity" (for mean protein intensity), 
#' "iBAQ" (for mean iBAQ intensity) or "Mol..Weight..kDa."
#' (as expected after importing a proteinGroups.txt file generated by MaxQuant using read.csv ).
#' @param bait_gene_name The gene name of the bait
#' @param Column_gene_name df's column corresponding to gene names
#' @param Column_intensity_pattern Pattern (regular exrpression) used to identfy df's columns containing protein intensity values
#' @param N_rep number of iteration for the replacement of missing values
#' (if \code{Nrep}=0, missing values are not replaced)
#' @param bckg_bait Τhe name of the bait found in \code{bckg} (see below) or in df's names if \code{bckg} is not provided
#' @param bckg_ctrl Τhe name of the control background found in \code{bckg} (see below) or in df's names if \code{bckg} is not provided
#' @param bckg Vector of length equal to the number of protein intensity columns indicating which background a column refers to 
#' (containing either  \code{bckg_bait} or  \code{bckg_ctrl} )
#' @param time Vector of length equal to the number of protein intensity columns indicating experimental conditions  
#' (for instance time of stimulation)
#' @param bio Vector of length equal to the number of protein intensity columns indicating biological replicates
#' @param tech Vector of length equal to the number of protein intensity columns indicating technical replicates
#' @param preffix_time Preffix for experimental conditions in column names (i.e "t" if pattern is "_t300")
#' @param preffix_bio Preffix for biological replicates in column names (i.e "S" if pattern is "_S1")
#' @param preffix_tech Preffix for technical replicates in column names (i.e "R" if pattern is "_R3")
#' @param filter_time vector of experimental conditions to exclude from analysis
#' @param filter_bio vector of biological replicates to exclude from analysis
#' @param filter_tech vector of technical replicates to exclude from analysis
#'
#'
#' @return a object of class \code{Interactome}, i.e a list including the following elements :
#' \code{conditions} : a vector of experimental conditions; 
#' \code{names} : a vector of names (by default gene names are used); 
#' \code{p_val} : a list of vectors containing the p values associated to each experimental condition; 
#' \code{fold_change} : a list of vectors containing the fold change associated to each experimental condition; 
#' \code{...} : other variables
#'
#' @import dplyr
#' @import ggplot2
#' @import ggrepel
#' @import grid
#' @import stringr
#' 
#' @export
#'
#' @author Guillaume Voisinne
#'
#' @examples
#' 
#' #load data :
#' dir<- system.file("extdata", package = "InteRact")
#' path <- paste(dir,"/proteinGroups_Cbl.txt",sep="")
#' df <- read.csv(path, sep="\t", nrows=-1, fill=TRUE, na.strings="", dec=".")
#' 
#' res <- InteRact(df, bait_gene_name = "Cbl")
#' 
#' # Check which columns have been used along with their description
#' print.data.frame(res$cond)
#' 
#' # You now have an object of class \code{InteRactome} that you can plot
#' Interactome <- res$Interactome
#' plot(Interactome)
#' plot_volcanos(Interactome, show_plot = TRUE )
#' 
#' # and manipulate by filtering conditions :
#' Interactome <- filter_conditions(Interactome, Interactome$conditions[1] )
#' plot(Interactome)
#' 
#' #or by re-ordering its elements (proteins)
#' order_list <- get_order_discrete(Interactome)
#' Interactome <- order_interactome(Interactome, order_list$idx_order)
#' #Print Interactome by experimental condition :
#' plot_per_conditions(Interactome, idx_rows = min(30, order_list$Ndetect))
#' 
#' # You can identify columns and their description separately using \code{identify_conditions()}
#' cond <- identify_conditions(df, bckg_bait="Cbl")
#' print.data.frame(cond)
#' # and use it as parameters for function \code{InteRact()}
#' res <- InteRact(df, bait_gene_name = "Cbl", bckg=cond$bckg, time=cond$time, bio=cond$bio, tech=cond$tech)
#' 
#' # You can define your own default pattern for intensity columns :
#' pattern = "^iBAQ"
#' cond <- identify_conditions(df, bckg_bait="Cbl", Column_intensity_pattern = pattern))
#' # Let's check that these column contain numeric variables
#' sapply( grep(pattern,names(df)), function(x) typeof( df[, x] ) ) 
#' # Make sure to use the same pattern in function \code{InteRact()}
#' res <- InteRact(df, Column_intensity_pattern = pattern, bait_gene_name = "Cbl", bckg=cond$bckg, time=cond$time, bio=cond$bio, tech=cond$tech)
#' 

InteRact <- function(df,
                     Column_gene_name = "Gene.names",
                     bait_gene_name,
                     N_rep=10,
                     bckg_bait = bait_gene_name,
                     bckg_ctrl = "WT",
                     bckg = NULL,
                     time=NULL,
                     bio=NULL,
                     tech=NULL,
                     Column_intensity_pattern = "^Intensity.",
                     preffix_bio="S",
                     preffix_tech="R",
                     preffix_time="",
                     filter_time=NULL,
                     filter_bio=NULL,
                     filter_tech=NULL
                     ){
  
  if( sum( sapply( grep(Column_intensity_pattern,names(df)), function(x) is.factor( df[, x] ) ) ) >0 ){
    stop("Some intensity columns are factors, try changing the decimal separator (most likely '.' or ',') used for importing the data")
  }
  
  df$gene_name <- sapply(df[[Column_gene_name]], function(x) strsplit(as.character(x),split=";")[[1]][1] )
  
  df<-filter_Proteins(df);
  df$Npep <- estimate_Npep(df)
  ibait <- which(df$gene_name == bait_gene_name);
  if(length(ibait)==0){
    stop(paste("Could not find",bait_gene_name,"in column",Column_gene_name, sep=" ")) 
  }
  
  # Identify conditions corresponding to intensity columns
  idx_col<-grep(Column_intensity_pattern,colnames(df))
  T_int <- df[ ,idx_col];
  col_I <- colnames(T_int)
  
  if( is.null(bckg) | is.null(time) | is.null(bio) | is.null(tech) ){
    cond <- identify_conditions(df, 
                                Column_intensity_pattern = Column_intensity_pattern, 
                                bckg_bait = bckg_bait, 
                                bckg_ctrl = bckg_ctrl,
                                preffix_time = preffix_time,
                                preffix_bio = preffix_bio, 
                                preffix_tech = preffix_tech )
  }
  else{
    cond <- dplyr::tibble(idx=seq_along(col_I), column=col_I, bckg, time, bio, tech)
  }
  

  # filter out some experimental conditions
  
  cond_filter <- cond
  idx_filter <- c( unlist( lapply(filter_time, function(x) l=which(cond$time==x) ) ) , 
                   unlist( lapply(filter_bio, function(x) l=which(cond$bio==x) ) ),
                   unlist( lapply(filter_tech, function(x) l=which(cond$tech==x) ) ) )
  
  if(!is.null(idx_filter) && length(idx_filter)>0 ){
    cond_filter <- cond[-idx_filter,] 
  }
  cat(idx_filter)
  
  #Normalize on median intensity across conditions
  
  T_int[T_int==0] <- NA;
  T_int_norm <- rescale_median(T_int);
  cat("Rescaling median intensity across conditions\n")
  
  avg <- average_technical_replicates(T_int_norm, cond_filter)
  
  T_int_norm_mean = avg$Intensity
  idx_cond = avg$conditions
  
  # identify missing values
  
  log10_T_int_norm_mean <- log10(T_int_norm_mean);
  
  q <- quantile(log10_T_int_norm_mean[ , idx_cond$bckg==bckg_ctrl], na.rm=TRUE, probs=0.01);
  s <- mean( row_sd(log10_T_int_norm_mean[ ,idx_cond$bckg==bckg_ctrl]), na.rm=TRUE);
  
  log10_T_int_norm_mean_rep<-log10_T_int_norm_mean;
  
  # replace missing values
  
  if(N_rep>0){
    
    res <- vector("list", N_rep)
    names(res)<-paste( rep('Rep_',N_rep), 1:N_rep, sep="" )
    cat(paste("Replacing missing values and performing interactome analysis for",N_rep,"replicates\n",sep=" "))
    
    n_replace <- length(which(is.na(log10_T_int_norm_mean)));
    for(i in 1:N_rep){
      
      cat(paste("Nrep=",i,"\n",sep=""));
      log10_T_int_norm_mean_rep[is.na(log10_T_int_norm_mean)] <- rnorm( n_replace, mean=q, sd=s) 
      Tfinal <- 10^log10_T_int_norm_mean_rep
      rownames(Tfinal)<-df$gene_name
      
      res[[i]]<-analyse_interactome(df = Tfinal, bait_gene_name = bait_gene_name, ibait = ibait[[1]], Npep = df$Npep, 
                                   name_bait = bckg_bait, name_ctrl = bckg_ctrl,
                                   background = idx_cond$bckg, conditions = idx_cond$time, replicates = idx_cond$bio , 
                                   by_conditions = TRUE, log_transf = TRUE)
      res[[i]]$protein_ID <- df$Protein.IDs
      
    }
    
    res_mean = mean_analysis(res);
    
    
  }else{
    
    Tfinal <- 10^log10_T_int_norm_mean
    rownames(Tfinal)<-df$gene_name
    
    res_mean<-analyse_interactome(df = Tfinal, ibait = ibait[[1]], Npep = df$Npep,
                                 name_bait = bckg_bait, name_ctrl = bckg_ctrl,
                                 background = idx_cond$bckg, conditions = idx_cond$time, replicates = idx_cond$bio , 
                                 by_conditions = TRUE, log_transf = TRUE)
    res_mean$protein_ID <- df$Protein.IDs
  }
  
  res_mean <- global_analysis(res_mean);
  
  output=list( Interactome = res_mean, conditions = cond, conditions_filtered=cond_filter, mean_data = avg);
  
}


#' Identify conditions (background, time of stimulation, biological and technical replicates) 
#' from column names
#' @export
identify_conditions <- function(df,
                                Column_intensity_pattern = "^Intensity.",
                                bckg_bait,
                                bckg_ctrl = "WT",
                                preffix_bio="S",
                                preffix_tech="R",
                                preffix_time=""
                                ){
  idx_col<-grep(Column_intensity_pattern,colnames(df))
  T_int <- df[ ,idx_col];
  
  col_I <- colnames(T_int)
  
  s<-unlist( strsplit(unlist(strsplit(col_I, Column_intensity_pattern)), split="_") )
  
  rad_number<-unique( stringr::str_match(s, "([A-z]+)[0-9]")[,2] )
  rad_number[is.na(rad_number)] <- "";
  
  bckg<-vector("character",length(col_I));
  
  rad_no_number <- unique( stringr::str_match(s, "([A-z]+)")[,2] )
  rad_no_number[is.na(rad_no_number)] <- ""
  
  rad_unique <- lapply(rad_number, function(x)  unique(s[grep(x, s)] )) 
  rad_unique_length <- lapply(rad_number, function(x) length( unique(s[grep(x, s)] )) )
  rad_unique <- unlist( rad_unique[rad_unique_length==1] )
  
  rad<-rad_number[rad_unique_length>1]
  bckg_names <- union( setdiff(rad_no_number, rad_number), rad_unique)
  
  if( !is.element(preffix_bio, rad) ){
    warning(paste("preffix_bio '",preffix_bio,"' cannot be found in column names. Suggested preffixes are '", paste(rad, collapse="'; '"),"'",sep="" ))
  }
  if( !is.element(preffix_tech, rad) ){
    warning(paste("preffix_tech '",preffix_tech,"' cannot be found in column names. Suggested preffixes are '", paste(rad, collapse="'; '"),"'",sep="" ))
  }
  if( !is.element(preffix_time, rad) ){
    warning(paste("preffix_time '",preffix_time,"' cannot be found in column names. Suggested preffixes are '", paste(rad, collapse="'; '"),"'",sep="" ))
  }
  
  idx_bait <- grep(bckg_bait,col_I);
  if(length(idx_bait)>0){
    bckg[grep(bckg_bait,col_I)]<-bckg_bait;
  }else{
    warning(paste("Could not find '", bckg_bait,"' in column names. Suggested background names are '", paste(bckg_names, collapse="'; '"),"'",sep=""))
  }
  
  idx_ctrl <- grep(bckg_ctrl,col_I);
  if(length(idx_ctrl)>0){
    bckg[grep(bckg_ctrl,col_I)]<-bckg_ctrl;
  }else{
    warning(paste("Could not find '", bckg_ctrl,"' in column names. Suggested background names are '", paste(bckg_names, collapse="'; '"),"'",sep=""))
  }

  pattern_time <-paste("[._]",preffix_time,"([0-9]+)",sep="")
  time <- as.numeric(stringr::str_match(col_I, pattern_time)[,2] )

  pattern_bio <-paste("[._]",preffix_bio,"([0-9]+)",sep="")
  bio <- as.numeric( stringr::str_match(col_I, pattern_bio)[,2] )

  pattern_tech <-paste("[._]",preffix_tech,"([0-9]+)",sep="")
  tech <- as.numeric(stringr::str_match(col_I, pattern_tech)[,2] )
  
  cond <- dplyr::tibble(idx=seq_along(col_I), column=col_I, bckg, time, bio, tech)
  
}


#' Averaging of protein intensities over technical replicates
#' @param df A data frame of protein intensities
#' @param conditions A data frame containing the description of df's columns (i.e "idx", bckg", "time", "bio"  and "tech")
#' @return A list containing :
#' \code{Intensity}, a data frame of protein intensities averaged over technical replicates;
#' \code{conditions}, a data frame containing the description of Intensity's columns
#' @export
average_technical_replicates<-function(df, cond){
  
  cond_group <- dplyr::group_by(cond, bckg, time, bio)
  idx_cond <-  dplyr::summarize(cond_group, idx_all=list(idx))
  
  cond_name <- vector("character", dim(idx_cond)[1])
  df_mean = data.frame( matrix( NA, nrow = dim(df)[1], ncol=dim(idx_cond)[1] ) );
  
  for(j in 1:dim(idx_cond)[1]){
    cond_name[j] = paste( idx_cond$bckg[j], 't', idx_cond$time[j], 'rep', idx_cond$bio[j], sep="_");
    df_mean[[j]] <- rowMeans(df[ idx_cond$idx_all[[j]] ], na.rm=TRUE);
  }
  colnames(df_mean)=cond_name;
  
  output = list(Intensity=df_mean, conditions=idx_cond)
  
}

#' Filtering of a data frame using a threshold on protein identification score and 
#' gene names
#' @param df A data frame
#' @param min_score Threshold for protein identification score
#' @param Column_gene_name The name of df's column containing gene names
#' @return A filtered data frame 
#' @export
filter_Proteins <- function( df, min_score=0, Column_gene_name= "Gene.names"){

  idx_row = 1:dim(df)[1]
  if( "Score" %in% colnames(df)){
    idx_row= which( df$Score>min_score )
    df<-df[idx_row, ]
    cat("Data Filtered based on portein identification score\n")
  }else{
    warning("Column Score not available : Data NOT Filtered based on portein identification score\n")
  }
  
  #Remove contaminants from dataset
  
  if( Column_gene_name %in% colnames(df)){
    
    df<-df[ - grep("KRT",toupper(df[[Column_gene_name]])), ]
    cat("Contaminant proteins were discarded\n")
    
    idx_name <- which( nchar(as.character(df[[Column_gene_name]])) > 0  )
    if(length(idx_name)>0){
      df <- df[ idx_name, ]
      cat("Proteins with no gene name available were discarded\n")
    }
    
  }else{
    warning(paste("Column gene_name '", Column_gene_name, "' not available",sep=""))
  }
  
  output = df
}

#' @export
estimate_Npep <- function(df){
  
  if( "Intensity" %in% colnames(df) & "iBAQ" %in% colnames(df)){
    Npep <- round( as.numeric( as.character(df$Intensity))/as.numeric( as.character(df$iBAQ)) )
    cat("Number of theoretically observable peptides computed using iBAQ values\n")
  }else if("Mol..weight..kDa." %in% colnames(df) ){ 
    Npep <- df$Mol..weight..kDa.
    cat("Number of theoretically observable peptides unavailable : used MW instead\n")
  }else{
    Npep <- rep(1,dim(df)[1])
    cat("Number of theoretically observable peptides unavailable : set to 1\n")
  }
  output<-Npep
}

#' @export
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  
  library(grid)
  
  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)
  
  numPlots = length(plots)
  
  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                     ncol = cols, nrow = ceiling(numPlots/cols))
  }
  
  if (numPlots==1) {
    print(plots[[1]])
    
  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
    
    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
      
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}

#' @export
rescale_median <- function(df){
  df_out<-df;
  for (i in seq_along(df)){
    df_out[[i]] <- df[[i]]/median(df[[i]], na.rm=TRUE);
  }
  df_out
}

#' @export
row_sd <- function(df){
  output<-vector("double", dim(df)[1] )
  for(i in 1:dim(df)[1] ){
    output[i] <- sd(df[i,],na.rm=TRUE);
  }
  output
}

#' @export
row_ttest <- function(df, idx_group_1, idx_group_2, log_transf = TRUE){
  # compares groups of column values using a t-test for each row.
  # idx_group_1 : indexes of columns for group #1
  # idx_group_2 : indexes of columns for group #2
  # log_transf : if TRUE, performs the t-test on log transform data
  
  p_val <- rep(NaN,dim(df)[1]);
  fold_change <- rep(NaN,dim(df)[1]);
  output <- data.frame(p_val=p_val, fold_change=fold_change);
  
  if(log_transf){
    df_test<-log10(df)
  }else{
    df_test<-df
  }
  
  for(i in (1:dim(df)[1]) ){
    res<-try(t.test(df_test[i, idx_group_1], df_test[i, idx_group_2]), silent=TRUE)
    if(!inherits(res,"try-error")){
      p_val[i] <- res$p.value;
      fold_change[i] <- 10^(res$estimate[1]-res$estimate[2])
    }
  }
  output$p_val <- p_val;
  output$fold_change <- fold_change;
  output
  
}

#' @export
row_stoichio <- function(df, idx_group_1, idx_group_2, idx_bait, Npep){
  # compute stoichiometry of interaction for each row (protein).
  # idx_group_1 : indexes of columns for group #1 (OST bait)
  # idx_group_2 : indexes of columns for group #2 (WT)
  # idx_bait : row index for the bait
  # N_pep : vector with the number of theoretical observable peptides for each row (protein).
  
  stoichio <- rep(NaN,dim(df)[1]);
  
  xbait1<-df[idx_bait, idx_group_1]
  xbait2<-df[idx_bait, idx_group_2]
  
  for(i in (1:dim(df)[1]) ){
    x1<-df[i, idx_group_1]
    x2<-df[i, idx_group_2]
    stoichio[i] <- ( mean(x1)-mean(x2) ) / ( mean(xbait1)-mean(xbait2) )*Npep[idx_bait]/Npep[i]
  }
  stoichio
}

#' @export
analyse_interactome <- function( df, ibait, bait_gene_name, Npep, name_bait, name_ctrl, 
                                 background, conditions, replicates, 
                                 by_conditions = TRUE, log_transf = TRUE){
  # df :  dataframe of intensities. columns are experimental samples and rows are proteins
  # ibait : row index corresponding to the bait protein
  # Npep : vector containing the number of theoretically observable peptide per protein (same length as dim(df)[1])
  # name_bait : name of the bait as appearing in the background vector
  # name_ctrl : name of the control as appearing in the background vector
  # background : vector of background names for each experimental sample
  # conditions : vector of conditions for each each experimental sample
  # replicates : vector of biological replicates for each each experimental sample
  # by_conditions : if TRUE, comparison of intensities between background are performed for each experimental condition independantly
  # log_transf : if TRUE, comparison between groups are perform on log transformed protein intensities
  
  if(!by_conditions){
    conds<-rep(-1,length(background))
  }else{
    conds<-conditions
  }
  cond<-unique(conds);
  
  
  p_val <- vector("list",length(cond));
  fold_change <- vector("list",length(cond));
  stoichio <- vector("list",length(cond));
  names(p_val)<-as.character(cond);
  names(fold_change)<-as.character(cond);
  names(stoichio)<-as.character(cond);
  
  for( i in seq_along(cond) ){
    
    ttest <- row_ttest(df, 
                            which( background==name_bait & conds==cond[[i]]), 
                            which( background==name_ctrl & conds==cond[[i]]), 
                            log_transf = log_transf)
    p_val[[i]]<-ttest$p_val;
    fold_change[[i]]<-ttest$fold_change;
    stoichio[[i]] <- row_stoichio(df, 
                                  which( background==name_bait & conds==cond[[i]] ), 
                                  which( background==name_ctrl & conds==cond[[i]]), 
                                  idx_bait=ibait,
                                  Npep=Npep)
  }
  
  res = list(bait = bait_gene_name, 
             groups = paste(name_bait," vs ", name_ctrl, sep=""), 
             conditions= as.character(cond), 
             names=row.names(df), 
             p_val=p_val, 
             fold_change=fold_change, 
             stoichio=stoichio)
  
  class(res) <- 'InteRactome'
  
  return(res)
}

#' @export
mean_analysis <- function( res ){
  
  # average results from multiple call to function 'analyse_interactome'
  
  cat(paste("Averaging", length(res) ,"interactomes\n",sep=" ") )
  res_mean = res[[1]];
  
  for ( cond in seq_along(res_mean$conditions) ){
    p_val=vector("list",length(res));
    fold_change=vector("list",length(res));
    stoichio = vector("list",length(res));
    for ( i in seq_along(res)){
      p_val[[i]] <- res[[i]]$p_val[[cond]]
      fold_change[[i]] <- res[[i]]$fold_change[[cond]]
      stoichio[[i]] <- res[[i]]$stoichio[[cond]]
    }
    res_mean$p_val[[cond]] <- 10^( rowMeans( log10(do.call(cbind, p_val))) )
    #res_mean$sd_log10_p_val[[cond]] <- row_sd( log10(do.call(cbind, p_val))) 
    res_mean$fold_change[[cond]] <- 10^( rowMeans( log10(do.call(cbind, fold_change))) )
    res_mean$stoichio[[cond]] <- 10^ (rowMeans( log10(do.call(cbind, stoichio))) )
  }
  
  res_mean
  
}

#' @export
filter_conditions <- function (x, ...) {
  UseMethod("filter_conditions", x)
}

#' Filters conditions from an interactome
#' @export
filter_conditions.InteRactome <- function( res, conditions_to_filter_out ){
  
  idx_conditions <- which(is.element(res$conditions, conditions_to_filter_out ))
  res_filter<-res
  res_filter$conditions <- res$conditions[-idx_conditions]
    
  for(i in 1:length(res)){
    if( setequal( names(res[[i]]), res$conditions ) ){
      res_filter[[i]] <- res[[i]][-idx_conditions]
    }
  }
  if( "norm_stoichio" %in% names(res) ){
    res_filter <- global_analysis(res_filter)
  }
  return(res_filter)
}

#' @export
global_analysis <- function (x, ...) {
  UseMethod("global_analysis", x)
}

#' @export
global_analysis.InteRactome <- function( res ){
  
  res_int <- res;
  max_stoichio<- apply( do.call(cbind, res$stoichio), 1, function(x)  ifelse( sum(!is.na(x))>0, max(x,na.rm=TRUE),NaN) )
  max_stoichio[!is.finite(max_stoichio)]<-NaN
  res_int$max_stoichio <- max_stoichio
  
  matrix_fold_change<-do.call(cbind, res$fold_change)
  res_int$max_fold_change <- apply(matrix_fold_change , 1, function(x)  ifelse( sum(!is.na(x))>0, max(x,na.rm=TRUE),NaN) )
  
  matrix_p_val<-do.call(cbind, res$p_val)
  matrix_p_val[matrix_fold_change<1]<-NA # keep only p_values corresponding to a fold_change >1 
  res_int$min_p_val <- apply( matrix_p_val, 1, function(x)  ifelse( sum(!is.na(x))>0, min(x,na.rm=TRUE),NaN) )
  
  norm_stoichio = vector("list",length(res$conditions))
  names(norm_stoichio)<-res$conditions
  for ( i in seq_along(res$conditions) ){
    norm_stoichio[[i]] <- res$stoichio[[i]] / max_stoichio
  }
  res_int$norm_stoichio <- norm_stoichio
  
  output=res_int
  
}

#' @export
append_annotations <- function (x, ...) {
  UseMethod("append_annotations", x)
}

#' @export
append_annotations.InteRactome <- function( res ){
  
  res_int <- res;
  
  nodes<-res_int$names
  nodes_IDs<- as.character(res_int$protein_ID);
  nodes_ID<-rep("",length(nodes));
  imatch<-rep(0,length(nodes));
  imatch_review<-rep("",length(nodes));
  nodes_gene_names<-rep("NA",length(nodes));
  nodes_entry_names<-rep("",length(nodes));
  nodes_status<-rep("unreviewed",length(nodes));
  
  for (i in 1:length(nodes) ){
    list_nodes_ID<- unique(strsplit(nodes_IDs[i],split=";")[[1]]);
    for(j in 1:length(list_nodes_ID) ){
      nID_clean <- strsplit(list_nodes_ID[j], split="-")[[1]][1];
      if(j==1){
        nodes_ID[i]<-nID_clean;
      }
      idx_entry<-which(uniprot_data$Entry==nID_clean)
      if(length(idx_entry>0)) {
        
        if(imatch[i]==0){
          imatch[i]<-idx_entry;
          nodes_ID[i]<-nID_clean;
        }
        
        if(uniprot_data$Status[idx_entry]=="reviewed"){
          imatch[i]<-idx_entry;
          imatch_review[i]<-paste(imatch_review[i],idx_entry,collapse=";")
          nodes_ID[i]<-nID_clean;
          nodes_status[i]="reviewed"
          break;
        }
      }
    }
    
    if(imatch[i]>0){
      s1<-strsplit(as.character(uniprot_data$Gene.names[imatch[i]]),split=" ")[[1]][1];
      s2<-strsplit(as.character(uniprot_data$Entry.name[imatch[i]]),split="_")[[1]][1];
      nodes_gene_names[i]<-s1;
      nodes_entry_names[i]<-s2
      if(is.na(s1)){
        nodes_gene_names[i]<- "NA" #as.character(Tuni$Entry.name[imatch[i]]);
      }
      if(substr(nodes_gene_names[i],1,1)=="\""){
        nodes_gene_names[i]=nodes[i];
      }
    }
    
  }
  
  res_int$status_reviewed <- nodes_status;
  res_int$protein_ID_reviewed<-nodes_ID;
  res_int$entry_name_reviewed <- nodes_entry_names;
  res_int$gene_name_reviewed <- nodes_gene_names;
  
  res_int$gene_name <- nodes_gene_names;
  res_int$gene_name[which(nchar(nodes_gene_names)==0)] <- res_int$names[which(nchar(nodes_gene_names)==0)]
  
  res_int$gene_name_plot = res_int$gene_name
  res_int$gene_name_plot[res_int$prey=="Q60787TAG"]<-"OST"
  res_int$gene_name_plot[res_int$gene_name=="Rps27a"]<-"Ub"
  
  ### list keywords for each node
  
  
  ukeys_nodes_collapse <-rep("",length(nodes));
  uGOs_nodes_collapse<-rep("",length(nodes));
  uPFs_nodes_collapse<-rep("",length(nodes));
  
  for( i in 1:length(nodes) ){
    if(imatch[i]>0){
      
      ukeys_nodes_collapse[i]<-as.character(uniprot_data$Keywords[imatch[i]]);
      
      uGOs_nodes_collapse[i]<-as.character(uniprot_data$Gene.ontology.IDs[imatch[i]]);
      
      s<-strsplit(as.character(uniprot_data$Protein.families[imatch[i]]), split=", ");
      uPFs_nodes_collapse[i]<-paste(s[[1]], collapse="; ");

    }
    
  }
  
  res_int$keywords = ukeys_nodes_collapse;
  res_int$GO_IDs = uGOs_nodes_collapse;
  res_int$Protein_families = uPFs_nodes_collapse;
  
  output=res_int
}

#' @export
merge_proteome <- function (x, ...) {
  UseMethod("merge_proteome", x)
}

#' @export
merge_proteome.InteRactome <- function( res, matching="names" ){
  
      res_int <- res;
    
      gene_name_prot <- proteome_data$Gene.names;
    
      ibait <- match(res$bait, res$names)
      
      ######### Retrieve protein abundance and compute related quantities
      
      Copy_Number <- rep(0, length(res$names));
    
      for( i in 1:length(res$names) ){
        idx_prot <- which(gene_name_prot==as.character(res[[matching]][i]));
        idx_ID_x <-  which(proteome_data$Protein.IDs.x==as.character(res$nodes_ID_reviewed[i]));
        idx_ID_y <-  which(proteome_data$Protein.IDs.y==as.character(res$nodes_ID_reviewed[i]));
        abund_x <- NA;
        abund_y <- NA;
        if( length(idx_ID_x)>0 ){ 
          abund_x <- proteome_data$mean.x[idx_ID_x] 
        }
        if( length(idx_ID_y)>0 ){ 
          abund_y <- proteome_data$mean.y[idx_ID_y] 
        }
        
        if(length(idx_prot)>0){
          Copy_Number[i] = proteome_data$mean[ idx_prot[1] ];
        }else if( length(idx_ID_x)>0 || length(idx_ID_y)>0 ){
          Copy_Number[i] = mean( c(abund_x, abund_y), na.rm=TRUE);
        }else{
          Copy_Number[i] = NA;
        }
      }
      res_int$Copy_Number = Copy_Number
      res_int$stoch_abundance = Copy_Number / Copy_Number[ibait]
      
      #res_int$N_complex= Tsum$max_stoch*Copy_Number[ibait]
      #res_int$percentage_prey_in_complex = Tsum$max_stoch*Copy_Number[ibait]/Copy_Number;
      
      # Tsum$Perc_t_0 = Tsum$Stoch_t_0*Copy_Number[ibait]/Copy_Number;
      # Tsum$Perc_t_30 = Tsum$Stoch_t_30*Copy_Number[ibait]/Copy_Number;
      # Tsum$Perc_t_120 = Tsum$Stoch_t_120*Copy_Number[ibait]/Copy_Number;
      # Tsum$Perc_t_300 = Tsum$Stoch_t_300*Copy_Number[ibait]/Copy_Number;
      # Tsum$Perc_t_600 = Tsum$Stoch_t_600*Copy_Number[ibait]/Copy_Number;
  
      output=res_int
}

#' @export
plot_2D_stoichio <- function (x, ...) {
  UseMethod("plot_2D_stoichio", x)
}

#' @export
plot_2D_stoichio.InteRactome <- function( res, xlim=NULL, ylim=NULL, N_display=30){
  
  df<- data.frame( X=log10(res$max_stoichio), 
                   Y=log10(res$stoch_abundance), 
                   label_tot=res$names,
                   max_fold_change= res$max_fold_change
                   )
  
  df<-df[1:min(N_display, dim(df)[1]), ]
  
  xc <- -0.5
  yc <- 0
  rc<-1
  
  ylow <- -3
  
  if(is.null(xlim) & is.null(ylim)){
    max_range <- max( max(df$X,na.rm=TRUE)-min(df$X,na.rm=TRUE),  max(df$Y,na.rm=TRUE)-ylow )
    center_x <- ( max(df$X,na.rm=TRUE)+min(df$X,na.rm=TRUE) )/2
    center_y <- (max(df$Y,na.rm=TRUE)+ylow)/2
  }else{
    max_range <- max( xlim[2] - xlim[1],  ylim[2] - ylim[1] )
    center_x <- ( xlim[2] + xlim[1] )/2
    center_y <- ( ylim[2] + ylim[1] )/2
  }
  xmin<-center_x - max_range/1.9
  xmax<-center_x + max_range/1.9
  ymin<-center_y - max_range/1.9
  ymax<-center_y + max_range/1.9
  
  ylow_plot <- max(ylow,ymin)
  
  df$size_prey <- log10(df$max_fold_change)/max_range*20
  df$size_label <- unlist(lapply(log10(df$max_fold_change), function(x) { ifelse(x>0.5, min(c(x,3)), 0.5) }))/max_range*20/3
  df$sat_max_fold_t0 <- rep(1,dim(df)[1])
  
  idx_plot <- which(df$X<=xmax & df$X>=xmin & df$Y<=ymax & df$Y>=ymin)
  df <- df[idx_plot, ]
  
  p<-ggplot(df,aes(x=X, y=Y,label=label_tot)) +
    theme(aspect.ratio=1) +
    scale_color_gradient2(midpoint=0,  low="blue", mid=rgb(0,0,0), high="red",  space = "Lab" )+
    geom_polygon(data=data.frame(x=c(ylow_plot,xmax,xmax),y=c(ylow_plot,ylow_plot,xmax)), mapping=aes(x=x, y=y),alpha=0.1,inherit.aes=FALSE) +
    annotate("path",
             x=xc+rc*cos(seq(0,2*pi,length.out=100)),
             y=yc+rc*sin(seq(0,2*pi,length.out=100)), color=rgb(0,0,0,0.5) ) +
    annotate("segment", x = ylow_plot, xend = xmax, y = ylow_plot, yend = xmax, colour = rgb(0,0,0,0.5) ) +
    annotate("segment", x = xmin, xend = xmax, y = ylow_plot, yend = ylow_plot, colour = rgb(0,0,0,0.5) , linetype = "dashed") +
    xlab("log10(Interaction Stoichiometry)") +
    ylab("log10(Abundance Stoichiometry)") +
    geom_point(mapping=aes(x=df$X,y=df$Y,color=df$sat_max_fold_t0), size=df$size_prey, alpha=0.2, stroke=0, inherit.aes = FALSE, show.legend = FALSE)+
    coord_cartesian(xlim = c(xmin,xmax), ylim = c(ymin,ymax), expand = FALSE)+
    #geom_density_2d(colour=rgb(1,0,0),size=0.5) +
    geom_text_repel(mapping=aes(x=df$X,y=df$Y,label=label_tot,color=df$sat_max_fold_t0), size=df$size_label,force=0.002, 
                    segment.size = 0.1,
                    min.segment.length = unit(0.15, "lines"), 
                    point.padding = NA, inherit.aes = FALSE, show.legend = FALSE, max.iter = 100000)
  return(p)
  #print(p)
  #output=p
}

#' @export
get_order_discrete <- function (x, ...) {
  UseMethod("get_order_discrete", x)
}

#' @export
get_order_discrete.InteRactome <- function( res , p_val_breaks=c(1,0.1,0.05,0.01), p_val_thresh = 0.01, fold_change_thresh = 1){
  
  p_val_breaks_order <- p_val_breaks[order(p_val_breaks, decreasing=TRUE)]
  min_p_val_discrete <- rep(1, length(res$min_p_val));
  
  for( i in 1:length(p_val_breaks_order) ){
    min_p_val_discrete[res$max_fold_change>fold_change_thresh & res$min_p_val <= p_val_breaks_order[i] ]<-p_val_breaks_order[i];
  }
  
  Ndetect<-length(which( res$min_p_val<=p_val_thresh & res$max_fold_change>=fold_change_thresh) )
  idx_order<-order( min_p_val_discrete, 1/res$max_stoichio, decreasing =FALSE)
  
  output = list(idx_order=idx_order, Ndetect= Ndetect, min_p_val_discrete = min_p_val_discrete)
  return(output)
}

#' @export
order_interactome <- function (x, ...) {
  UseMethod("order_interactome", x)
}

#' @export
order_interactome.InteRactome <- function(res, idx_order){
  
  if(length(idx_order)!=length(res$names)){
    stop("Vector of ordering indexes does not have the proper length")
  }
  res_order<-res;
  for( var in setdiff( names(res), c("bait","groups","conditions") ) ){
    names_var <- names(res[[var]])
    if( length(names_var)>0 ){
      for(i in 1:length(names_var) ){
        res_order[[var]][[i]] <- res[[var]][[i]][idx_order]
      }
    }
    else{
      res_order[[var]] <- res[[var]][idx_order]
    }
  }
  output = res_order
}

#' @export
plot_Intensity_histogram <- function( I, I_rep, breaks=20, save_file=NULL){
    # plot histogram of intensities for all columns in two different datasets 
    # (1st dataset is in in black, 2nd dataset is in red)
    if(!is.null(save_file)){
      pdf( save_file, 4, 4 )
    }
    
    
    for( j in seq_along(I) ){
      h<-hist( I[[j]] , breaks=breaks, plot=FALSE);
      if(j>1){
        lines(h$mids,h$density,col=rgb(0,0,0,0.2));
      }else{
        plot(h$mids, h$density, type="l",col=rgb(0,0,0,0.2),ylim=c(0,1), xlim=range(I_rep));
      }
    }
    
    for( j in seq_along(I_rep) ){
      h<-hist( I_rep[[j]] , breaks=breaks, plot=FALSE);
      lines(h$mids,h$density,col=rgb(1,0,0,0.2));
    }
    
    if(!is.null(save_file)){
      dev.off()
    }
  
}

#' @export
plot_volcanos <- function (x, ...) {
  UseMethod("plot_volcanos", x)
}

#' @export
plot_volcanos.InteRactome <- function( res, 
                                       labels=res$names, 
                                       N_print=15, 
                                       conditions=res$conditions, 
                                       p_val_thresh=NULL, 
                                       fold_change_thresh=NULL, 
                                       save_file=NULL, 
                                       show_plot=FALSE){

  plist <- vector("list",length(conditions));
  
  ymax <- -log10(min(do.call(cbind,res$p_val)))
  xmax <- max(abs(log10(do.call(cbind,res$fold_change))))
  
  x1 <- log10(fold_change_thresh)
  x2 <- xmax
  y1 <- -log10(p_val_thresh)
  y2 <- ymax
  
  
  for( i in seq_along(conditions) ){
    
    df <- data.frame(p_val=res$p_val[[conditions[i]]], 
                     fold_change= res$fold_change[[conditions[i]]], 
                     names=labels)
    
    if(!is.null(p_val_thresh) & !is.null(fold_change_thresh)){
      is_above_thresh <- rep(0, dim(df)[1])
      is_above_thresh[which(df$p_val <= p_val_thresh & df$fold_change >= fold_change_thresh)]<-1
      idx_print <- order(is_above_thresh, df$fold_change, decreasing = TRUE)[1:min(N_print, sum(is_above_thresh))]
    }else{
      idx_print <- order(df$fold_change, decreasing = TRUE)[1:N_print]
    }
    
      
    plist[[i]] <- ggplot( df , aes(x=log10(fold_change), y=-log10(p_val) ) ) +
      scale_y_continuous(limits=c(0,ymax)) +
      scale_x_continuous(limits=c(-xmax,xmax)) +
      ggtitle(conditions[i])
      
    
    if(!is.null(p_val_thresh) & !is.null(fold_change_thresh)){
      plist[[i]] <- plist[[i]] +
        geom_polygon(data=data.frame(x=c(x1,x2,x2,x1),y=c(y1,y1,y2,y2)), mapping=aes(x=x, y=y),alpha=0.1,inherit.aes=FALSE) +
        annotate("segment", x = -x2, xend = x2, y = y1, yend = y1, colour = rgb(1,0,0,0.5) ) +
        annotate("segment", x = -x1, xend = -x1, y = 0, yend = y2, colour = rgb(1,0,0,0.5) ) +
        annotate("segment", x = x1, xend = x1, y = 0, yend = y2, colour = rgb(1,0,0,0.5) )
    }
    
    plist[[i]] <- plist[[i]] + 
      geom_point(alpha=0.2)+
      geom_text_repel(data=df[idx_print, ],
                      aes(label = names), col="red", size=5)
    
  }
  
  if(show_plot){
    layout <- matrix(1:length(conditions), nrow = 1, byrow = TRUE)
    multiplot(plotlist = plist, layout = layout)
  }
  if( length(save_file)>0 ){
    pdf( save_file, 4*length(conditions), 4 )
    layout <- matrix(1:length(conditions), nrow = 1, byrow = TRUE)
    multiplot(plotlist = plist, layout = layout)
    dev.off()
  }
  
  return(plist)
}

#' @export
plot <- function (x, ...) {
  UseMethod("plot", x)
}

#' @export
plot.InteRactome <- function(x, 
                             p_val_breaks=c(1,0.1,0.05,0.01), 
                             p_val_thresh = 0.01,
                             fold_change_thresh=1,
                             Nmax=30, 
                             size_var="norm_stoichio", 
                             size_range=c(0,1), 
                             save_file=NULL ){
  order_list <- get_order_discrete(x, p_val_breaks, p_val_thresh, fold_change_thresh )
  Interactome_order <- order_interactome(x, order_list$idx_order)
  plot_per_conditions(Interactome_order, 
                      idx_rows = min(Nmax, order_list$Ndetect), 
                      size_var=size_var, 
                      size_range=size_range, 
                      color_var="p_val", 
                      color_breaks=p_val_breaks, 
                      save_file=save_file )
}

#' @export
plot_per_conditions <- function (x, ...) {
  UseMethod("plot_per_conditions", x)
}

#' @export
plot_per_conditions.InteRactome <- function( res, 
                                 idx_rows=1:20,
                                 size_var="norm_stoichio",
                                 size_range=c(0,1),
                                 color_var="p_val", 
                                 color_breaks=c(1,0.1,0.05,0.01), 
                                 #color_values=rgb(t(col2rgb(c("black", "blue","purple","red")))/255),
                                 color_default = 1,
                                 save_file=NULL,
                                 show_plot=TRUE,
                                 plot_width=3.25,
                                 plot_height=length(idx_rows)/(plot_width+1) + 1 ){
  
  if(length(idx_rows)==1){
    idx_rows<-1:idx_rows
  }
  
  M<-do.call(cbind, res[[size_var]])
  M1<-do.call(cbind, res[[color_var]])
    
  row.names(M) <- unlist(lapply(res$names, function(x) substr(x,1,min(8,nchar(x))) ) )
  Mcol<-M
  Mcol[!is.null(M)]<-color_default
  
   if(!is.null(color_var)){
     idx_order_col <- order(color_breaks, decreasing = TRUE);
     for(i in seq_along(color_breaks)){
       Mcol[M1<color_breaks[idx_order_col[i]]]<-color_breaks[idx_order_col[i]]
     }
   }
  
  p<-dot_plot( as.matrix(M[idx_rows, ]), 
               as.matrix(Mcol[idx_rows,]), 
               title = res$groups,
               size_var = size_var, 
               size_range=size_range,
               color_var=color_var)
  
  if(show_plot){
    print(p)
  }
  
  if(!is.null(save_file)){
    pdf(save_file, plot_width, plot_height)
    print(p)
    dev.off()
  }
  
  return(p)
  
}

#' @export
dot_plot <- function(Dot_Size, 
                     Dot_Color=NULL, 
                     title="Dot Plot", 
                     size_range=range(Dot_size) , 
                     size_var ="size", 
                     color_var="color"){
  
  # Dot_Size: matrix of dot size
  
  M<-Dot_Size
  Mcol <- Dot_Color
  
  ylabels <- row.names(M)
  if(length(ylabels)==0){
    ylabels <- 1:dim(M)[1]
  }
  
  xlabels <- colnames(M)
  if(length(xlabels)==0){
    xlabels <- 1:dim(M)[2]
  }
  
  xpos <- vector("list", dim(M)[2] );
  ypos <- vector("list", dim(M)[2] );
  size <- vector("list", dim(M)[2] );
  if(length(Dot_Color)>0){
    if( sum(dim(M) != dim(M))==0 ){
      color <- vector("list", dim(M)[2] );
    }else{
      stop("Dimensions of size and color matrix do not match")
    }
  }
  
  pos <- 1+dim(M)[1] - ( 1:dim(M)[1] )
  
  for( k in 1:dim(M)[2] ){
    xpos[[k]] <- rep(k, dim(M)[1] )
    ypos[[k]] <- pos
    size[[k]] <- as.numeric(M[,k]);
    if(length(Dot_Color)>0){
      color[[k]] <- Mcol[,k];
    }
  }
  
  df<-data.frame( xpos=unlist(xpos), ypos=unlist(ypos), size=unlist(size) );
  if(length(Dot_Color)>0){
    df$color = unlist(color)
  }else{
    df$color = rep( 1, dim(df)[1] )
  }
  
  df$color<-as.factor(df$color)
  
  unique_col <- unique(df$color);
  size_label_y <- max(6, 16 - (dim(M)[1] %/% 10)*1.5 )
  
  p <- ggplot(df, aes(x=xpos, y=ypos, size=size, col=color ) ) +
    theme(#plot.margin=unit(c(0.2,0,0,0), "cm"),
      plot.title = element_text(size=12),
      axis.text.y= element_text(size=size_label_y), 
      axis.text.x = element_text(size=16, angle = 90, hjust = 1,vjust=0.5) ) +
    ggtitle(title)+
    scale_color_manual( values=c( "red", "purple",  "blue", "black" ) , name=color_var) +
    scale_radius(limits=size_range, name=size_var) +
    #scale_colour_manual(values=setNames(unique_col, c( "red", "purple",  "blue", "black" ) )) +
    xlab("") +
    ylab("") +
    scale_x_continuous(breaks=1:dim(M)[2],
                       limits=c(0.75, dim(M)[2]+0.25),
                       labels=xlabels) +
    scale_y_continuous(breaks=pos,
                       limits=c(0.5, dim(M)[1]+0.5),
                       labels=ylabels) +
    geom_point(alpha=0.5, show.legend = TRUE)
  
  output=p
  
}

#' @export
summary_table <- function (x, ...) {
  UseMethod("summary_table", x)
}

#' @export
summary_table.InteRactome <- function(res, add_columns = NULL){
  
  columns <- unique( c("names", add_columns) )
  #columns <- add_columns
  columns <- setdiff(columns, c("bait","groups","conditions"))
  
  df<-data.frame( bait=rep(res$bait, length(res$names)) )
  names_df<-"bait"
  idx<-1
  
  for( var in columns ){
    names_var <- names(res[[var]])
    if( length(names_var)>0 ){
      for(i in 1:length(names_var) ){
        idx<-c(idx,NaN)
        names_df<-c(names_df, paste(var,"_",names_var[i],sep=""))
        df<-cbind(df,res[[var]][[i]])
      }
    }
    else{
      idx<-c(idx,1)
      names_df<-c(names_df, var)
      df<-cbind(df,res[[var]])
    }
  }
  names(df)<-names_df
  df<-df[,order(idx)]
  
  output = df
  
}



################################################### Example ###################################################

#data( proteinGroups, package="InteRact" )
#bait_gene_name = "Cbl"
#path_to_file = "~/Google_Drive/++Work/++Research/++Projects/Interactomes-New/ProteinGroups_ALL/Original_files/proteinGroups_Cbl.txt"
#T<-read.csv(path_to_file, header=TRUE, sep="\t", nrows=-1, quote="\"", fill=TRUE, na.strings="", dec=".")

#assign( "proteinGroups", T)
#save("proteinGroups", file= paste( "~/proteinGroups.Rdata",sep="") )

#Interactome <- InteRact(T, bait_gene_name = bait_gene_name)

#plot_volcanos(Interactome, show_plot = TRUE )

# save_dir=paste("~/Desktop/Interactome_", bait_gene_name, sep="")
# dir.create(save_dir, showWarnings = FALSE)
# unlink(paste(save_dir,"/*",sep=""))

# plot_volcanos(Interactome, save_file = paste(save_dir,"/volcano_plot.pdf",sep="") , show_plot = FALSE )
# 
# order_list <- get_order(Interactome)
# Interactome <- order_interactome(Interactome, order_list$idx_order)
# 
# plot_per_conditions(Interactome, idx_rows = min(30, order_list$Ndetect), save_file = paste(save_dir,"/norm_stoichio.pdf",sep="") )
# 
# # save interactome
# interactome_name=paste("Interactome_",bait_gene_name, sep="")
# assign( interactome_name, Interactome)
# save(list=interactome_name, file= paste( save_dir,"/Interactome_", bait_gene_name, ".Rdata",sep=""))

