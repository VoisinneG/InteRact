load("./R/sysdata.rda")

#' Analysis of proteomics data
#'
#' This package implements several functions to analyze Affinity Purification data.
#' 
#' By default, it is configured to work with proteinGroups.txt files
#' generated by MaxQuant
#'
#' @param df A dataframe containing protein intensities. By default, protein intensity column names start by "Intensity." 
#' (use parameter \code{Column_intensity_pattern} to change)
#' @param bait_gene_name The gene name of the bait
#' @param Column_score Column with protein identification score
#' @param Column_ID Column with protein IDs
#' @param Column_Npep Column with number of theoretically observable peptides per protein
#' @param Column_gene_name Column with gene names
#' @param Column_intensity_pattern Pattern (regular exrpression) used to identfy df's columns containing protein intensity values
#' @param N_rep number of iterations for the replacement of missing values
#' (if \code{Nrep}=0, missing values are not replaced)
#' @param quantile_rep Quantile of control background intensities used to replace missing values
#' @param bckg_bait Τhe name of the bait found in \code{bckg} (see below) or in df's names if \code{bckg} is not provided
#' @param bckg_ctrl Τhe name of the control background found in \code{bckg} (see below) or in df's names if \code{bckg} is not provided
#' @param bckg Vector of length equal to the number of protein intensity columns indicating which background a column refers to 
#' (containing either  \code{bckg_bait} or  \code{bckg_ctrl} )
#' @param time Vector of length equal to the number of protein intensity columns indicating experimental conditions  
#' (for instance time of stimulation)
#' @param bio Vector of length equal to the number of protein intensity columns indicating biological replicates
#' @param tech Vector of length equal to the number of protein intensity columns indicating technical replicates
#' @param preffix_time Preffix for experimental conditions in column names (i.e "t" if pattern is "_t300")
#' @param preffix_bio Preffix for biological replicates in column names (i.e "S" if pattern is "_S1")
#' @param preffix_tech Preffix for technical replicates in column names (i.e "R" if pattern is "_R3")
#' @param filter_time vector of experimental conditions to exclude from analysis
#' @param filter_bio vector of biological replicates to exclude from analysis
#' @param filter_tech vector of technical replicates to exclude from analysis
#' @param updateProgress function to show progress bar in shiny app
#' @param pool_background option to use all control background conditions as one control group for all conditions
#' @param log option to perform t-test and averages on log transform intensities
#' @param by_conditions option to perform the comparison between bait and control group for each condition
#'
#' @return a object of class \code{Interactome}, i.e a list including the following elements :
#' @return \code{conditions} : a vector of experimental conditions.
#' @return \code{names} : a vector of names (by default gene names are used).
#' @return \code{p_val} : a list of vectors containing the p values associated to each experimental condition.
#' @return \code{fold_change} : a list of vectors containing the fold change associated to each experimental condition. 
#' @return \code{...} : other variables.
#'
#' @import dplyr
#' @import ggplot2
#' @import ggrepel
#' @import grid
#' @import stringr
#' @import Hmisc
#' @import igraph
#' 
#' @export
#'
#' @author Guillaume Voisinne
#'
#' @examples
#' #load data :
#' dir<- system.file("extdata", package = "InteRact")
#' path <- paste(dir,"/proteinGroups_Cbl.txt",sep="")
#' df <- read.csv(path, sep="\t", nrows=-1, fill=TRUE, na.strings="", dec=".")
#' #Run InteRact with default parameters
#' res <- InteRact(df, bait_gene_name = "Cbl")
#' Interactome <- res$Interactome
#' #You now have an \code{InteRactome}. See its elements.
#' names(Interactome)
#' #Visualize results
#' plot(Interactome)
#' plot_volcanos(Interactome, show_plot = TRUE )
#' #Create a summary data frame
#' sum_tbl_2 <- summary_table(Interactome)
#' # Check which columns have been used along with their description
#' print.data.frame(res$cond)
#' # Identify interactors
#' Interactome <- identify_interactors(Interactome, p_val_thresh = 0.05, fold_change_thresh = 2)
#' # Append protein abundance
#' Interactome <- merge_proteome(Interactome)
#' # Order proteins in Interactome
#' order_list <- get_order_discrete(Interactome)
#' Interactome <- order_interactome(Interactome, order_list$idx_order)
#' # Append annotations
#' annot <- get_annotations(Interactome)
#' Interactome <- append_annotations(Interactome,  annot)
#' #Check the new summary data frame
#' sum_tbl_2 <- summary_table(Interactome)
InteRact <- function(df,
                     Column_gene_name = "Gene.names",
                     Column_score = "Score",
                     Column_ID = "Protein.IDs",
                     Column_Npep = NULL,
                     bait_gene_name,
                     N_rep=3,
                     quantile_rep  = 0.05,
                     bckg_bait = bait_gene_name,
                     bckg_ctrl = "WT",
                     bckg = NULL,
                     time=NULL,
                     bio=NULL,
                     tech=NULL,
                     Column_intensity_pattern = "^Intensity.",
                     # preffix_bio="S",
                     # preffix_tech="R",
                     # preffix_time="",
                     split = "_",
                     bckg_pos = 1,
                     bio_pos = 2,
                     time_pos = 3, 
                     tech_pos = 4,
                     filter_time=NULL,
                     filter_bio=NULL,
                     filter_tech=NULL,
                     updateProgress = NULL,
                     pool_background = TRUE, 
                     log = TRUE,
                     by_conditions = TRUE
                     ){
  
  if( sum( sapply( grep(Column_intensity_pattern,names(df)), function(x) is.factor( df[, x] ) ) ) >0 ){
    stop("Some intensity columns are factors, try changing the decimal separator (most likely '.' or ',') used for importing the data")
  }
  
  if(! Column_ID %in% names(df)){
    warning(paste("Column ", Column_ID, " could not be found", sep=""))
  }
  if(! Column_gene_name %in% names(df)){
    stop(paste("Column ", Column_gene_name, " could not be found", sep=""))
  }
  
  df$gene_name <- sapply(df[[Column_gene_name]], function(x) strsplit(as.character(x),split=";")[[1]][1] )
  
  df<-filter_Proteins(df, Column_gene_name = Column_gene_name, Column_score = Column_score);
  
  df$Npep <- estimate_Npep(df, Column_Npep = Column_Npep)
  
  idx_col<-grep(Column_intensity_pattern, colnames(df))
  if(length(idx_col)==0){
    stop("Couldn't find pattern in column names")
  }
  
  df <- merge_duplicate_groups(df, idx_col = idx_col, merge_column = "gene_name")
  
  T_int <- df[ ,idx_col];
  col_I <- colnames(T_int)
  
  ibait <- which(df$gene_name == bait_gene_name);
  if(length(ibait)==0){
    stop(paste("Could not find bait '",bait_gene_name,"' in column '",Column_gene_name,"'", sep="")) 
  }
  
  # Identify conditions corresponding to intensity columns
  
  
  if( is.null(bckg) | is.null(time) | is.null(bio) | is.null(tech) ){
    # cond <- identify_conditions(df, 
    #                             Column_intensity_pattern = Column_intensity_pattern, 
    #                             bckg_bait = bckg_bait, 
    #                             bckg_ctrl = bckg_ctrl,
    #                             preffix_time = preffix_time,
    #                             preffix_bio = preffix_bio, 
    #                             preffix_tech = preffix_tech )
    
    cond <- identify_conditions_2(df, 
                                Column_intensity_pattern = Column_intensity_pattern, 
                                split = "_",
                                bckg_pos = 1,
                                bio_pos = 2,
                                time_pos = 3, 
                                tech_pos = 4 )
    
    
  } else {
    cond <- dplyr::tibble(idx=seq_along(col_I), column=col_I, bckg, time, bio, tech)
  }
  

  # filter out some experimental conditions
  
  cond_filter <- cond
  idx_filter <- c( unlist( lapply(filter_time, function(x) l=which(cond$time==x) ) ) , 
                   unlist( lapply(filter_bio, function(x) l=which(cond$bio==x) ) ),
                   unlist( lapply(filter_tech, function(x) l=which(cond$tech==x) ) ) )
  
  if(!is.null(idx_filter) && length(idx_filter)>0 ){
    
    cat("Filter following intensity columns :\n")
    cat(idx_filter)
    cat("\n")
    
    cond_filter <- cond[-idx_filter,] 
    
  }
  
  
  #Normalize on median intensity across conditions
  
  T_int[T_int==0] <- NA;
  T_int_norm <- rescale_median(T_int);
  cat("Rescale median intensity across conditions\n")
  
  avg <- average_technical_replicates(T_int_norm, cond_filter)
  
  T_int_norm_mean = avg$Intensity
  idx_cond = avg$conditions
  
  # identify missing values
  
  log10_T_int_norm_mean <- log10(T_int_norm_mean);
  
  q <- quantile(log10_T_int_norm_mean[ , idx_cond$bckg==bckg_ctrl], na.rm=TRUE, probs=quantile_rep);
  s <- mean( row_sd(log10_T_int_norm_mean[ ,idx_cond$bckg==bckg_ctrl]), na.rm=TRUE);
  
  log10_T_int_norm_mean_rep<-log10_T_int_norm_mean;
  
  # replace missing values
  
  if(N_rep>0){
    
    res <- vector("list", N_rep)
    names(res)<-paste( rep('Rep_',N_rep), 1:N_rep, sep="" )
    cat(paste("Replace missing values and perform interactome analysis for",N_rep,"replicates\n",sep=" "))
    
    n_replace <- length(which(is.na(log10_T_int_norm_mean)));
    for(i in 1:N_rep){
      
      if (is.function(updateProgress)) {
        text <- paste0( i, "/", N_rep)
        updateProgress(value = i/N_rep*100, detail = text)
      }
      
      cat(paste("Nrep=",i,"\n",sep=""));
      log10_T_int_norm_mean_rep[is.na(log10_T_int_norm_mean)] <- rnorm( n_replace, mean=q, sd=s) 
      Tfinal <- 10^log10_T_int_norm_mean_rep
      rownames(Tfinal)<-df$gene_name
      
      res[[i]]<-analyse_interactome(df = Tfinal, bait_gene_name = bait_gene_name, ibait = ibait[[1]], Npep = df$Npep, 
                                   name_bait = bckg_bait, name_ctrl = bckg_ctrl,
                                   background = idx_cond$bckg, conditions = idx_cond$time, replicates = idx_cond$bio , 
                                   pool_background = pool_background, log = log, by_conditions = by_conditions)
      res[[i]]$Protein.IDs <- df[[Column_ID]]
      
    }
    
    res_mean = mean_analysis(res, log = log, na.rm = TRUE);
    
    
  }else{
    
    Tfinal <- 10^log10_T_int_norm_mean
    rownames(Tfinal)<-df$gene_name
    
    res_mean<-analyse_interactome(df = Tfinal, bait_gene_name = bait_gene_name, ibait = ibait[[1]], Npep = df$Npep,
                                 name_bait = bckg_bait, name_ctrl = bckg_ctrl,
                                 background = idx_cond$bckg, conditions = idx_cond$time, replicates = idx_cond$bio , 
                                 pool_background = pool_background, log = log, by_conditions = by_conditions)
    res_mean$protein_ID <- df[[Column_ID]]
  }
  
  res_mean <- global_analysis(res_mean);
  
  output=list( Interactome = res_mean, conditions = cond, conditions_filtered=cond_filter, mean_data = avg);
  
}


#' Identify conditions (background, time of stimulation, biological and technical replicates) 
#' from column names
#'
#' @param df A dataframe containing protein intensities. By default, protein intensity column names start by "Intensity." 
#' (use parameter \code{Column_intensity_pattern} to change)
#' @param Column_intensity_pattern Pattern (regular exrpression) used to identfy df's columns containing protein intensity values
#' @param bckg_bait Τhe name of the bait found in \code{bckg} (see below) or in df's names if \code{bckg} is not provided
#' @param bckg_ctrl Τhe name of the control background found in \code{bckg} (see below) or in df's names if \code{bckg} is not provided
#' @param preffix_time Preffix for experimental conditions in column names (i.e "t" if pattern is "_t300")
#' @param preffix_bio Preffix for biological replicates in column names (i.e "S" if pattern is "_S1")
#' @param preffix_tech Preffix for technical replicates in column names (i.e "R" if pattern is "_R3")
#' @return a data frame describing experimental samples in terms of background, 
#' biological and technical replicates, and experimental conditions
#' @import dplyr
#' @import stringr
#' @export
#' @examples
#' #load data :
#' dir<- system.file("extdata", package = "InteRact")
#' path <- paste(dir,"/proteinGroups_Cbl.txt",sep="")
#' df <- read.csv(path, sep="\t", nrows=-1, fill=TRUE, na.strings="", dec=".")
#' # You can identify columns and their description separately using \code{identify_conditions()}
#' cond <- identify_conditions(df, bckg_bait="Cbl")
#' print.data.frame(cond)
#' # and use it as parameters for function \code{InteRact()}
#' res <- InteRact(df, bait_gene_name = "Cbl", bckg=cond$bckg, time=cond$time, bio=cond$bio, tech=cond$tech)
identify_conditions <- function(df,
                                Column_intensity_pattern = "^Intensity.",
                                bckg_bait,
                                bckg_ctrl = "WT",
                                preffix_bio = "S",
                                preffix_tech = "R",
                                preffix_time = "",
                                split = "_"
                                ){
  idx_col<-grep(Column_intensity_pattern,colnames(df))
  if(length(idx_col)==0){
    stop("Couldn't find pattern in column names")
  }
  
  T_int <- df[ ,idx_col];
  
  col_I <- colnames(T_int)
  
  s<-unlist( strsplit(unlist(strsplit(col_I, Column_intensity_pattern)), split=split, fixed=TRUE) )
  
  rad_number<-unique( stringr::str_match(s, "([A-z]+)[0-9]")[,2] )
  rad_number[is.na(rad_number)] <- "";
  
  bckg<-vector("character",length(col_I));
  
  rad_no_number <- unique( stringr::str_match(s, "([A-z]+)")[,2] )
  rad_no_number[is.na(rad_no_number)] <- ""
  
  rad_unique <- lapply(rad_number, function(x)  unique(s[grep(x, s)] )) 
  rad_unique_length <- lapply(rad_number, function(x) length( unique(s[grep(x, s)] )) )
  rad_unique <- unlist( rad_unique[rad_unique_length==1] )
  
  rad<-rad_number[rad_unique_length>1]
  bckg_names <- union( setdiff(rad_no_number, rad_number), rad_unique)
  
  if( !is.element(preffix_bio, rad) ){
    warning(paste("preffix_bio '",preffix_bio,"' cannot be found in column names. Suggested preffixes are '", paste(rad, collapse="'; '"),"'",sep="" ))
  }
  if( !is.element(preffix_tech, rad) ){
    warning(paste("preffix_tech '",preffix_tech,"' cannot be found in column names. Suggested preffixes are '", paste(rad, collapse="'; '"),"'",sep="" ))
  }
  if( !is.element(preffix_time, rad) ){
    warning(paste("preffix_time '",preffix_time,"' cannot be found in column names. Suggested preffixes are '", paste(rad, collapse="'; '"),"'",sep="" ))
  }
  
  idx_bait <- grep(bckg_bait,col_I);
  if(length(idx_bait)>0){
    bckg[grep(bckg_bait,col_I)]<-bckg_bait;
  }else{
    warning(paste("Could not find '", bckg_bait,"' in column names. Suggested background names are '", paste(bckg_names, collapse="'; '"),"'",sep=""))
  }
  
  idx_ctrl <- grep(bckg_ctrl,col_I);
  if(length(idx_ctrl)>0){
    bckg[grep(bckg_ctrl,col_I)]<-bckg_ctrl;
  }else{
    warning(paste("Could not find '", bckg_ctrl,"' in column names. Suggested background names are '", paste(bckg_names, collapse="'; '"),"'",sep=""))
  }

  pattern_time <-paste(split, preffix_time,"([0-9]+)",sep="")
  time <- as.numeric(stringr::str_match(col_I, pattern_time)[,2] )

  pattern_bio <-paste(split,preffix_bio,"([0-9]+)",sep="")
  bio <- as.numeric( stringr::str_match(col_I, pattern_bio)[,2] )

  pattern_tech <-paste(split,preffix_tech,"([0-9]+)",sep="")
  tech <- as.numeric(stringr::str_match(col_I, pattern_tech)[,2] )
  
  cond <- dplyr::tibble(idx=seq_along(col_I), column=col_I, bckg, time, bio, tech)
  
}

identify_conditions_2 <- function(df,
                                  Column_intensity_pattern = "^Intensity.",
                                  split = "_",
                                  bckg_pos = 1,
                                  bio_pos = 2,
                                  time_pos = 3, 
                                  tech_pos = 4
                                  ){
  idx_col<-grep(Column_intensity_pattern,colnames(df))
  if(length(idx_col)==0){
    stop("Couldn't find pattern in column names")
  }
  
  T_int <- df[ ,idx_col];
  
  col_I <- colnames(T_int)
  
  s0 <- sapply(strsplit(col_I, Column_intensity_pattern), function(x){x[2]})
  s <- strsplit(s0, split=split, fixed=TRUE)
  n <- length(s[[1]])
  
  if(bckg_pos > n) stop("bckg_pos too large")
  if(bio_pos > n) stop("bio_pos too large")
  if(tech_pos > n) stop("tech_pos too large")
  if(time_pos > n) stop("time_pos too large")
  
  bckg <- unlist(lapply(s, function(x){x[bckg_pos]}))
  bio<- unlist(lapply(s, function(x){x[bio_pos]}))
  tech <- unlist(lapply(s, function(x){x[tech_pos]}))
  time <- unlist(lapply(s, function(x){x[time_pos]}))
  
  cond <- dplyr::tibble(idx=seq_along(col_I), column=col_I, bckg, time, bio, tech)

}


#' Average protein intensities over technical replicates
#' 
#' @param df A data frame of protein intensities
#' @param cond A data frame containing the description of df's columns (i.e "idx", bckg", "time", "bio"  and "tech") 
#' as returned by function \code{identify_conditions}
#' @return A list containing :
#' @return \code{Intensity}, a data frame of protein intensities averaged over technical replicates;
#' @return \code{conditions}, a data frame containing the description of Intensity's columns
#' @examples
#' #load data :
#' dir<- system.file("extdata", package = "InteRact")
#' path <- paste(dir,"/proteinGroups_Cbl.txt",sep="")
#' df <- read.csv(path, sep="\t", nrows=-1, fill=TRUE, na.strings="", dec=".")
#' # You can identify columns and their description separately using \code{identify_conditions()}
#' cond <- identify_conditions(df, bckg_bait="Cbl")
#' print.data.frame(cond)
#' Column_intensity_pattern <- "^Intensity."
#' df_int <- df[ , grep(Column_intensity_pattern, colnames(df))]
#  avg <- average_technical_replicates(df_int, cond)
average_technical_replicates<-function(df, cond){
  
  cond_group <- dplyr::group_by(cond, bckg, time, bio)
  idx_cond <-  dplyr::summarize(cond_group, idx_all=list(idx))
  
  cond_name <- vector("character", dim(idx_cond)[1])
  df_mean = data.frame( matrix( NA, nrow = dim(df)[1], ncol=dim(idx_cond)[1] ) );
  
  for(j in 1:dim(idx_cond)[1]){
    cond_name[j] = paste( idx_cond$bckg[j], 't', idx_cond$time[j], 'rep', idx_cond$bio[j], sep="_");
    df_mean[[j]] <- rowMeans(df[ idx_cond$idx_all[[j]] ], na.rm=TRUE);
  }
  colnames(df_mean)=cond_name;
  
  output = list(Intensity=df_mean, conditions=idx_cond)
  
}

#' Filtering of a data frame using a threshold on protein identification score and 
#' gene names
#' 
#' @param df A data frame
#' @param min_score Threshold for protein identification score
#' @param Column_gene_name The name of df's column containing gene names
#' @return A filtered data frame 
#' @examples
#' #load data :
#' dir<- system.file("extdata", package = "InteRact")
#' path <- paste(dir,"/proteinGroups_Cbl.txt",sep="")
#' df <- read.csv(path, sep="\t", nrows=-1, fill=TRUE, na.strings="", dec=".")
filter_Proteins <- function( df, min_score=0, Column_gene_name = "Gene.names", Column_score= "Score", split_param=";"){

  idx_row = 1:dim(df)[1]
  if( Column_score %in% colnames(df)){
    idx_row= which( df[[Column_score]] > min_score )
    df<-df[idx_row, ]
    cat("Data Filtered based on portein identification score\n")
  }else{
    warning("Column 'Score' not available : Data NOT Filtered based on portein identification score\n")
  }
  
  #Remove contaminants from dataset
  
  if( Column_gene_name %in% colnames(df)){
    
    idx_cont <- grep("KRT",toupper(df[[Column_gene_name]]))
    if (length(idx_cont) > 0){
      df<-df[ - grep("KRT",toupper(df[[Column_gene_name]])), ]
      cat("Contaminant proteins discarded\n")
    }
    
    idx_name <- which( nchar(as.character(df[[Column_gene_name]])) > 0  )
    if(length(idx_name) > 0){
      df <- df[ idx_name, ]
      cat("Proteins with no gene name available discarded\n")
    }
    
  }else{
    warning(paste("Column gene_name '", Column_gene_name, "' not available",sep=""))
  }
  
  df$gene_name <- sapply(df[[Column_gene_name]], function(x) strsplit(as.character(x),split=split_param)[[1]][1] )
  
  return(df)
}

#' Merge protein groups with the same gene name.
#' 
#' @param df A data frame
#' @param idx_col idx of columns for which values will be merged across protein groups
#' @param merge_column column for which identical values will be merged
#' @return A merged data frame 
merge_duplicate_groups <- function(df, idx_col = NULL, merge_column = "gene_name"){
  
    cat("Merge protein groups associated to the same gene name (sum of intensities) \n")
    
    df_int <- df
    
    ugene <- unique(df[[merge_column]]);
    
    idx_merge = rep(1, dim(df)[1]); # rows with idx_merge = 0 will be filtered out
    
    for(i in 1:length(ugene) ){
      
      idx_u <- which( df[[merge_column]] == ugene[i] ) 
      
      if (length(idx_u) > 1) {
        max_I <- rep(0, length(idx_u));
        for (j in 1:length(idx_u) ){
          idx_merge[idx_u[j]] = 0;
          max_I[j] = max(df[ idx_u[j], idx_col])
        }
        jmax = which(max_I == max(max_I) );
        idx_merge[ idx_u[jmax] ] = 1;
        
        for (k in idx_col ){
          s=0;
          for(j in idx_u ){
            s= s + df[j, k];
          }
          df_int[idx_u[jmax], k] = s;
        }
        
      }
      
    }
    
    return(df_int[idx_merge>0, ])
    
}

#' Get the number of theoretically observable peptides per protein
#' 
#' @param df A data frame
#' @param Column_Npep column containing the number of theoretically observable peptides per protein.
#' If NULL try to compute the number of theoretically observable peptides using iBAQ values, 
#' or use molecular weight.
#' @return A data frame with the column 'Npep'
estimate_Npep <- function(df, Column_Npep = NULL){
  
  if ( is.null(Column_Npep) ){
    if( "Intensity" %in% colnames(df) & "iBAQ" %in% colnames(df)){
      Npep <- round( as.numeric( as.character(df$Intensity))/as.numeric( as.character(df$iBAQ)) )
      cat("Number of theoretically observable peptides computed using iBAQ values\n")
    }else if("Mol..weight..kDa." %in% colnames(df) ){ 
      Npep <- df$Mol..weight..kDa.
      cat("Number of theoretically observable peptides unavailable : used MW instead\n")
    }else{
      Npep <- rep(1,dim(df)[1])
      cat("Number of theoretically observable peptides unavailable : set to 1\n")
    }
  } else {
    Npep <- df[[Column_Npep]]
  }
  
  output<-Npep
}

#' Arrange multiple plots in a given layout
#' 
#' @param plotlist A list of plots
#' @param cols Number of columns to use (if \code{layout} is NULL)
#' @param layout layout of plots (a matrix representing the position of the different plots).
#' For instance layout = matrix(c(1,1,2,3), ncol=2, nrow=2) will plot the first plot in the upper 
#' half while the bottom half will be equally split between plots 2 and 3.
#' @return A plot
multiplot <- function(..., plotlist=NULL, cols=1, layout=NULL) {
  
  library(grid)
  
  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)
  
  numPlots = length(plots)
  
  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                     ncol = cols, nrow = ceiling(numPlots/cols))
  }
  
  if (numPlots==1) {
    print(plots[[1]])
    
  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
    
    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
      
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}

#' Normalize data frame by columns using the median
#' 
#' @param df A data frame
#' @return A normalized data frame
rescale_median <- function(df){
  df_out<-df;
  for (i in seq_along(df)){
    df_out[[i]] <- df[[i]]/median(df[[i]], na.rm=TRUE);
  }
  df_out
}

#' Perform the geometric mean of a numeric vector
#' 
#' @param x A numeric vector
#' @param na.rm remove NA values
#' @return A numeric value
geom_mean = function(x, na.rm=TRUE){
  exp(sum(log(x[x > 0]), na.rm=na.rm) / length(x))
}

#' Compute the standard deviation by row
#' 
#' @param df a data frame
#' @return A numeric vector
row_sd <- function(df){
  output<-vector("double", dim(df)[1] )
  for(i in 1:dim(df)[1] ){
    output[i] <- sd(df[i,],na.rm=TRUE);
  }
  output
}

#' Perform a t-test comparison between two groups by row
#' 
#' @param df a data frame
#' @param idx_group_1 column indexes corresponding to the first group
#' @param idx_group_2 column indexes corresponding to the second group
#' @param log option to perform the t-test on log transformed data
#' @return A data frame with columns 'p_val' and 'fold_change
row_ttest <- function(df, idx_group_1, idx_group_2, log = TRUE){
  
  p_val <- rep(NaN,dim(df)[1]);
  fold_change <- rep(NaN,dim(df)[1]);
  output <- data.frame(p_val=p_val, fold_change=fold_change);
  
  if(log){
    df_test<-log10(df)
  }else{
    df_test<-df
  }
  
  for(i in (1:dim(df)[1]) ){
    res<-try(t.test(df_test[i, idx_group_1], df_test[i, idx_group_2]), silent=TRUE)
    if(!inherits(res,"try-error")){
      p_val[i] <- res$p.value;
      if(log){
        fold_change[i] <- 10^(res$estimate[1] - res$estimate[2])
      } else {
        fold_change[i] <- res$estimate[1] / res$estimate[2]
      }
    }
  }
  output$p_val <- p_val;
  output$fold_change <- fold_change;
  output
  
}

#' Compute the stoichiometry of interaction using the method described in 
#' \ref{}
#' 
#' @param df a data frame
#' @param idx_group_1 column indexes corresponding to the first group (bait background)
#' @param idx_group_2 column indexes corresponding to the second group (ctrl background)
#' @param idx_bait row index for the bait protein
#' @param Npep numeric vector containing the number of theoretically observable peptides for each protein
#' @param log option to use the geometric mean instead of the arithmetic mean
#' @return A numeric vector of interaction stoichiometries
row_stoichio <- function(df, 
                         idx_group_1, 
                         idx_group_2, 
                         idx_bait, 
                         Npep, 
                         log = TRUE){
  # compute stoichiometry of interaction for each row (protein).
  # idx_group_1 : indexes of columns for group #1 (OST bait)
  # idx_group_2 : indexes of columns for group #2 (WT)
  # idx_bait : row index for the bait
  # N_pep : vector with the number of theoretical observable peptides for each row (protein).
  
  stoichio <- rep(NaN,dim(df)[1]);
  
  xbait1<-df[idx_bait, idx_group_1]
  xbait2<-df[idx_bait, idx_group_2]
  
  for(i in (1:dim(df)[1]) ){
    x1<-df[i, idx_group_1]
    x2<-df[i, idx_group_2]
    if (log) {
      stoichio[i] <- ( geom_mean(x1) - geom_mean(x2) ) / ( geom_mean(xbait1) - geom_mean(xbait2) )*Npep[idx_bait]/Npep[i]
    } else {
      stoichio[i] <- ( mean(x1) - mean(x2) ) / ( mean(xbait1) - mean(xbait2) )*Npep[idx_bait]/Npep[i]
    }
    
  }
  stoichio
}

#' @export
analyse_interactome <- function( df, ibait, bait_gene_name, Npep, name_bait, name_ctrl, 
                                 background, conditions, replicates, 
                                 by_conditions = TRUE, pool_background = TRUE, log = TRUE){
  # df :  dataframe of intensities. columns are experimental samples and rows are proteins
  # ibait : row index corresponding to the bait protein
  # Npep : vector containing the number of theoretically observable peptide per protein (same length as dim(df)[1])
  # name_bait : name of the bait as appearing in the background vector
  # name_ctrl : name of the control as appearing in the background vector
  # background : vector of background names for each experimental sample
  # conditions : vector of conditions for each each experimental sample
  # replicates : vector of biological replicates for each each experimental sample
  # by_conditions : if TRUE, comparison of intensities between background are performed for each experimental condition independantly
  # log_transf : if TRUE, comparison between groups are perform on log transformed protein intensities
  
  if(!by_conditions){
    conds<-rep(-1,length(background))
  }else{
    conds<-conditions
  }
  cond<-unique(conds);
  
  
  p_val <- vector("list",length(cond));
  fold_change <- vector("list",length(cond));
  stoichio <- vector("list",length(cond));
  
  names(p_val)<-as.character(cond);
  names(fold_change)<-as.character(cond);
  names(stoichio)<-as.character(cond);
  
  ubio <- unique(replicates)
  stoichio_bio <- vector("list",length(ubio))
  names(stoichio_bio) <- as.character(ubio)
  for (i_bio in 1:length(ubio)){
    stoichio_bio[[i_bio]] <- vector("list",length(cond))
    names(stoichio_bio[[i_bio]])<-as.character(cond)
  }
  
  
  
  for( i in seq_along(cond) ){
    
    idx_ctrl <- which( background == name_ctrl )
    if(!pool_background) {
      idx_ctrl <- which( background == name_ctrl & conds == cond[[i]] )
    } 
    
    ttest <- row_ttest(df, 
                       idx_group_1 = which( background==name_bait & conds==cond[[i]]), 
                       idx_group_2 = idx_ctrl, 
                       log = log)
    p_val[[i]]<-ttest$p_val;
    fold_change[[i]]<-ttest$fold_change;
    
    
    
    stoichio[[i]] <- row_stoichio(df, 
                                  idx_group_1 = which( background==name_bait & conds==cond[[i]] ), 
                                  idx_group_2 = idx_ctrl, 
                                  idx_bait=ibait,
                                  Npep=Npep,
                                  log = log )
    for (i_bio in 1:length(ubio)){
      
      idx_ctrl_bio <- which( background == name_ctrl & replicates == ubio[i_bio])
      if(!pool_background) {
        idx_ctrl_bio <- which( background == name_ctrl & conds == cond[[i]] & replicates == ubio[i_bio])
      } 
      
      stoichio_bio[[i_bio]][[i]] <- row_stoichio(df, 
                                                 idx_group_1 = which( background==name_bait & conds==cond[[i]] & replicates==ubio[i_bio]), 
                                                 idx_group_2 = idx_ctrl_bio, 
                                                 idx_bait=ibait,
                                                 Npep=Npep,
                                                 log = log)
    }
  }
  
  res = list(bait = bait_gene_name, 
             groups = paste(name_bait," vs ", name_ctrl, sep=""), 
             conditions= as.character(cond),
             replicates = as.character(ubio),
             names=row.names(df), 
             p_val=p_val, 
             fold_change=fold_change, 
             stoichio=stoichio,
             stoichio_bio = stoichio_bio)
  
  class(res) <- 'InteRactome'
  
  return(res)
}

#' @export
moving_average <- function(x, n){
  
  x_smooth <- x
  
  for (i in 1:length(x)){
    idx <- max(c(i-n, 1)):min(c(i+n, length(x))) 
    x_smooth[i] <- mean(x[idx], na.rm=TRUE)
  }
  
  return(x_smooth)
}

#' @export
smooth <- function (x, ...) {
  UseMethod("smooth", x)
}

#' Smooth selected variables across conditions
#' @export
smooth.InteRactome <- function( res,  n = 1, order_conditions = NULL, var_smooth = c("fold_change","p_val") ){
  
  res_smooth <- res
  
  if(!is.null(order_conditions)){
    idx_order <- order_conditions
  } else {
    idx_order <- 1:length(res$conditions)
  }
  
  for (var in var_smooth){
    M <- do.call(cbind, res[[var]])
    M_smooth <- M
    
    for (i in 1:dim(M)[1] ){
      M_smooth[i, idx_order] <- 10^(moving_average(log10(M[i, idx_order]), n))
    }
    
    for (i in 1:length(res$conditions)){
      res_smooth[[var]][[res$conditions[i]]] <- M_smooth[ , i]
    }
  }
  
    
  if( "norm_stoichio" %in% names(res) ){
    res_smooth <- global_analysis(res_smooth)
  }
  
  return(res_smooth)
}

#' @export
merge_conditions <- function( res,  selected_conditions = NULL){
# Merge different conditions from different interactomes into a single dataframe 
  
  df_merge <- NULL
  
  if (class(res) == "list"){
    
    for (i in 1:length(res)){
      if(class(res[[i]]) == "InteRactome"){
        if(is.null(selected_conditions)){
          conditions <- res[[i]]$conditions
        } else {
          conditions <- selected_conditions
        }
        for (cond in conditions){
          names <- res[[i]]$names
          df <- data.frame(
            bait = rep(res[[i]]$bait, length(names)),
            names = names,
            Protein.IDs = res[[i]]$Protein.IDs,
            conditions = rep(cond, length(names)), 
            p_val = res[[i]]$p_val[[cond]],
            fold_change = res[[i]]$fold_change[[cond]])
          
          df_merge <- rbind(df_merge, df)
        }
      } else {
        stop("Input is not of class 'InteRactome'")
      }
    }
  } else{
    if(class(res) == "InteRactome"){
      if(is.null(selected_conditions)){
        conditions <- res$conditions
      } else {
        conditions <- selected_conditions
      }
      for (cond in conditions){
        names <- res$names
        df <- data.frame(
          bait = rep(res$bait, length(names)),
          names = names,
          Protein.IDs = res$Protein.IDs,
          conditions = rep(cond, length(names)), 
          p_val = res$p_val[[cond]],
          fold_change = res$fold_change[[cond]])
                 
        df_merge <- rbind(df_merge, df)
      }
    } else {
      stop("Input is not of class 'InteRactome'")
    }
  
  }
  return(df_merge)
}


#' @export
#' @examples
#' df_merge <- merge_conditions(Interactome)
#' df_FDR <- compute_FDR_from_asymmetry(df_merge)
#' Interactome <- append_FDR(Interactome, df_FDR)
compute_FDR_from_asymmetry <- function( df, 
                                        c = seq(from = 0, to =4, by = 0.1),
                                        x0 = seq(from = 0, to =3, by = 0.1)){
  
  # Compute FDR using the asymmetry of the volcano plot
  # df : data.frame containing columns 'p_val' and 'fold_change'
  # y = c / (x-x0) with x = log10(fold_change), y=-log10(p_value)
  
  df_int<-df
  
  x <- log10(df$fold_change)
  y <- -log10(df$p_val)
  
  FDR <- rep(1, dim(df)[1])
  cat("Compute FDR...\n")
  pb <- txtProgressBar(min = 0, max = length(c)*length(x0), style = 3)
  count <- 0
  
  for (i in 1:length(c)){
    for (j in 1:length(x0)){
      idx_TP <- which(x>x0[j] & y>c[i]/(x-x0[j]) )
      idx_FP <- which(x<(-x0[j]) & y>c[i]/(-x-x0[j]) )
      TP_int <- length(idx_TP)
      FP_int <- length(idx_FP)
      FDR_int <- FP_int/(FP_int + TP_int)
      
      FDR[idx_TP[ FDR[idx_TP] >= FDR_int ]] <- FDR_int
      
      count <- count +1
      setTxtProgressBar(pb, count)
    }
  }
  close(pb)
  df_int$FDR <- FDR
  
  return(df_int)
  
}

#' @export
#' @examples
#' df_merge <- merge_conditions(Interactome)
#' df_FDR <- compute_FDR_from_asymmetry(df_merge)
#' Interactome <- append_FDR(Interactome, df_FDR)
append_FDR <- function( res, df){
# res : an object of class InteRactome
# df : a data.frame containing (at least) columns 'bait', names', 'FDR' and 'conditions'
  
  res_int <- res
  df_int <- df
  
  df_int <- df_int[which(df_int$bait == res$bait), ]
  
  FDR <- list()
  
  for (cond in res$conditions){
    
    df_cond <- df_int[df_int$conditions == cond, ]
    idx_match <- match(res$names, df_cond$names)
    FDR[[cond]] <- df_cond$FDR[idx_match]
    
  }
  
  res_int$FDR <-FDR
  res_int <- global_analysis(res_int)
  
  return(res_int)
  
}

#' @export
filter_conditions <- function (x, ...) {
  UseMethod("filter_conditions", x)
}

#' Filters conditions from an interactome
#' @export
filter_conditions.InteRactome <- function( res, conditions_to_filter_out ){
  
  idx_conditions <- which(is.element(res$conditions, conditions_to_filter_out ))
  res_filter<-res
  res_filter$conditions <- res$conditions[-idx_conditions]
    
  for(i in 1:length(res)){
    if( setequal( names(res[[i]]), res$conditions ) ){
      res_filter[[i]] <- res[[i]][-idx_conditions]
    }
  }
  if( "norm_stoichio" %in% names(res) ){
    res_filter <- global_analysis(res_filter)
  }
  return(res_filter)
}

#' @export
mean_analysis <- function( res, log = TRUE, na.rm = TRUE ){
  
  # Performs the average of different interactomes
  
  cat(paste("Averaging", length(res) ,"interactomes\n",sep=" ") )
  res_mean = res[[1]];
  
  for ( cond in seq_along(res_mean$conditions) ){
    p_val=vector("list",length(res));
    fold_change=vector("list",length(res));
    stoichio = vector("list",length(res));
    for ( i in seq_along(res)){
      p_val[[i]] <- res[[i]]$p_val[[cond]]
      fold_change[[i]] <- res[[i]]$fold_change[[cond]]
      stoichio[[i]] <- res[[i]]$stoichio[[cond]]
    }
    if (log){
      res_mean$p_val[[cond]] <- 10^( rowMeans( log10(do.call(cbind, p_val)), na.rm =na.rm) )
      res_mean$fold_change[[cond]] <- 10^( rowMeans( log10(do.call(cbind, fold_change)), na.rm =na.rm) )
      res_mean$stoichio[[cond]] <- 10^ (rowMeans( log10(do.call(cbind, stoichio)), na.rm =na.rm) )
    } else {
      res_mean$p_val[[cond]] <-  rowMeans( do.call(cbind, p_val), na.rm =na.rm) 
      res_mean$fold_change[[cond]] <- rowMeans( do.call(cbind, fold_change), na.rm =na.rm) 
      res_mean$stoichio[[cond]] <- rowMeans( do.call(cbind, stoichio), na.rm =na.rm)
    }

    
    for (bio in res_mean$replicates){
      stoichio_bio <- vector("list",length(res));
      for ( i in seq_along(res)){
        stoichio_bio[[i]] <- res[[i]]$stoichio_bio[[bio]][[cond]]
      }
      if (log){
        res_mean$stoichio_bio[[bio]][[cond]] <- 10^( rowMeans( log10(do.call(cbind, stoichio_bio)), na.rm =na.rm) )
      } else {
        res_mean$stoichio_bio[[bio]][[cond]] <- rowMeans( do.call(cbind, stoichio_bio), na.rm =na.rm)
      }
    }
    
  }
  
  res_mean
  
}



#' @export
global_analysis <- function (x, ...) {
  UseMethod("global_analysis", x)
}

#' @export
global_analysis.InteRactome <- function( res ){
  
  res_int <- res;
  max_stoichio<- apply( do.call(cbind, res$stoichio), 1, function(x)  ifelse( sum(!is.na(x))>0, max(x,na.rm=TRUE),NaN) )
  max_stoichio[!is.finite(max_stoichio)]<-NaN
  res_int$max_stoichio <- max_stoichio
  
  matrix_fold_change<-do.call(cbind, res$fold_change)
  res_int$max_fold_change <- apply(matrix_fold_change , 1, function(x)  ifelse( sum(!is.na(x))>0, max(x,na.rm=TRUE),NaN) )
  
  matrix_p_val<-do.call(cbind, res$p_val)
  matrix_p_val[matrix_fold_change<1]<-NA # keep only p_values corresponding to a fold_change >1 
  res_int$min_p_val <- apply( matrix_p_val, 1, function(x)  ifelse( sum(!is.na(x))>0, min(x,na.rm=TRUE),NaN) )
  
  if( "FDR" %in% names(res) ){
    matrix_FDR<-do.call(cbind, res$FDR)
    res_int$min_FDR <- apply( matrix_FDR, 1, function(x)  ifelse( sum(!is.na(x))>0, min(x,na.rm=TRUE),NaN) )
  }
  
  norm_stoichio = vector("list",length(res$conditions))
  names(norm_stoichio)<-res$conditions
  for ( i in seq_along(res$conditions) ){
    norm_stoichio[[i]] <- res$stoichio[[i]] / max_stoichio
  }
  res_int$norm_stoichio <- norm_stoichio
  
  output=res_int
  
}

#' @export
annotation_enrichment_analysis <- function( df, 
                                            idx_detect, 
                                            annotation_selected = c("Keywords", "Protein.families") , 
                                            names = df$Gene.names...primary.., 
                                            organism = "mouse",
                                            updateProgress = NULL, 
                                            showProgress = TRUE,
                                            orderOutput = TRUE){
  # df : data frame with annotation data
  # idx_detect : indices of the subset of proteins in df for which the enrichment analysis is performed
  # (list of indices are supported. The output will then be a list of data-frames)
  # against the background formed by all proteins in df
  # annotation_selected : set of annotation terms to consider. 
  #Annotations supported are stored in varaiable "supported_annotations:
  
  supported_annotations <- c( 
                             "Protein.families",  
                             "Pfam", 
                             "Keywords", 
                             "Reactome", 
                             "GO",
                             "Hallmark",
                             "KEGG",
                             "GO_molecular_function",
                             "GO_biological_process",
                             "GO_cellular_component",
                             "GOslim_molecular_function",
                             "GOslim_biological_process",
                             "GOslim_cellular_component",
                             "Motif")
  

  if(  is.null(df) | (sum(names(df) %in% supported_annotations) == 0) | (sum(annotation_selected %in% names(df)) != length(annotation_selected)) ){
    stop("Annotations not available. Import annotations first.")
  }else if ( length(annotation_selected) == 0) {
    stop("No annotations selected. Change selected annotations")
  }else if (sum(annotation_selected %in% supported_annotations) != length(annotation_selected)){
    stop("Annotations not supported. Change selected annotations")
  }
  
  if (showProgress) cat("Perform annotation enrichment analysis...\n")
  
  #list annotation terms found in the dataset ------------------------------------------------
  
  df_int <- df
  
  if("Protein.families" %in% annotation_selected){
    df_int[["Protein.families"]] <- as.character(df_int[["Protein.families"]])
    for (i in 1:length(df_int[["Protein.families"]])){
      s <- strsplit(df_int[["Protein.families"]][i], split=", ")[[1]]
      s_develop <- s[1]
      if (length(s) > 1) {
        for (j in 2:length(s)){
          s_develop <- c(s_develop, paste(s_develop[length(s_develop)], s[j], sep=", "))
        }
      }
      df_int[["Protein.families"]][i] <- paste(s_develop, collapse="; ")
    }
  }
  
  annot_terms <- NULL
  annot_type <- NULL
  annot_names <- NULL
  
  for (annot_type_sel in annotation_selected){
    
      collapse_sep <- ";"
      if( annot_type_sel %in% c("Protein.families", "Keywords") ) collapse_sep <- "; "

      
      u_annot<-paste(unique(df_int[[annot_type_sel]]), collapse = collapse_sep)
      terms <- unique(strsplit(u_annot, split = collapse_sep)[[1]])
      
      annot_names_int <- terms
      if(annot_type_sel == "Reactome"){
        reactome <- switch(organism, "mouse" = reactome_mouse, "human" = reactome_human)
        annot_names_int <- paste(
                              reactome$Name[match(terms, reactome$ID)],
                              ", [",
                              reactome$ID[match(terms, reactome$ID)],
                              "]",
                              sep = "")
      }
      if(annot_type_sel == "Pfam"){
        pfam <- switch(organism, "mouse" = pfam_mouse, "human" = pfam_human)
        annot_names_int <- paste(
                                pfam$hmm.name[match(terms, pfam$hmm.acc)],
                                ", ",
                                pfam$type[match(terms, pfam$hmm.acc)],
                                ", [",
                                pfam$hmm.acc[match(terms, pfam$hmm.acc)],
                                "]",
                                sep = "")
      }
      
      annot_terms <- c(annot_terms,  terms)
      annot_type <- c(annot_type, rep(annot_type_sel, length(terms)))
      annot_names <- c(annot_names, annot_names_int)
      
  }
  
  df.annot <- data.frame(annot_terms = annot_terms, annot_type = annot_type, annot_names = annot_names)
  df.annot <- df.annot[which(df.annot$annot_terms != ""), ]

 
  
  # Compute Background -------------------------------------------------------------------------------------
  
  nodes_tot <- as.character(names);
  
  u_annot_nodes_collapse <- rep("", length(nodes_tot));
  idx_tot <- rep(0, length(nodes_tot));
  
  for ( i in 1:length(nodes_tot) ){
    s <- NULL
    for (annot_type in annotation_selected) {
      s <- c(s, as.character(df[[annot_type]][ i ]))
    }
    u_annot_nodes_collapse[i] <- paste(s, collapse = ";")
  }
  
  N_background = length(nodes_tot);
  
  n_annot <- dim(df.annot)[1]
  
  N_annot_background <- rep(0, n_annot);
  freq_annot_background <- rep(0, n_annot);
  nodes_annot_background <- rep("", n_annot);
  
  if (showProgress & typeof(idx_detect)!="list") pb <- txtProgressBar(min = 0, max = 2*n_annot, style = 3)
  count<-0
  
  for ( k in 1:dim(df.annot)[1] ){
    
    idx_annot <- grep(df.annot$annot_terms[k], u_annot_nodes_collapse, fixed=TRUE)
    N_annot_background[k] = length(idx_annot);
    nodes_annot_background[k] = paste(nodes_tot[idx_annot], collapse=";")
    freq_annot_background[k] = N_annot_background[k]/N_background;
    
    count <- count +1
    if (showProgress & typeof(idx_detect)!="list") setTxtProgressBar(pb, count)
    # progress bar
    if (is.function(updateProgress)) {
      text <- paste0( round(count/(2*n_annot)*100, 0), " %")
      updateProgress(value = count/(2*n_annot)*100, detail = text)
    }
  }
  
  N_annotation_test <- length(which(N_annot_background>0))
  
  # Perform enrichment test for each annotation and each subset of indices ---------------------------------------
  
  if (typeof(idx_detect)=="list"){
    n_sets <- length(idx_detect)
  } else {
    n_sets = 1
  }
  
  df.annot.tot <- list()
  
  if (showProgress  & typeof(idx_detect)=="list") pb <- txtProgressBar(min = 0, max = n_sets, style = 3)
      
  for (i in 1:n_sets){
    
    if (showProgress & typeof(idx_detect)=="list") setTxtProgressBar(pb, i)
    
    if (typeof(idx_detect)=="list"){
      idx_d <- idx_detect[[i]]
    } else {
      idx_d <- idx_detect
    }
    
    N_annot <- rep(0, n_annot);
    freq_annot <- rep(0, n_annot);
    nodes_annot <- rep("", n_annot);
    p_value <- rep(0, n_annot);
    fold_change <- rep(0, n_annot);
    p_value_adjust <- rep(0, n_annot);
    
    for(k in 1:n_annot ){
      
      
      idx_annot <- idx_d[ grep(df.annot$annot_terms[k], u_annot_nodes_collapse[idx_d],fixed=TRUE) ]
      N_annot[k]=length(idx_annot);
      N_sample = length(idx_d);
      
      freq_annot[k] = N_annot[k]/N_sample;
      nodes_annot[k]=paste(nodes_tot[idx_annot], collapse=";")
      
      p_value[k] = 1-phyper(N_annot[k]-1, 
                            N_annot_background[k],  
                            N_background-N_annot_background[k],  
                            N_sample);
      
      fold_change[k] = freq_annot[k]/freq_annot_background[k];
      
      count <- count +1
      if (showProgress & typeof(idx_detect)!="list") setTxtProgressBar(pb, count)
      # progress bar
      if (is.function(updateProgress)) {
        text <- paste0( round(count/(2*n_annot)*100, 0), " %")
        updateProgress(value = count/(2*n_annot)*100, detail = text)
      }
    }
    
    if (showProgress & typeof(idx_detect)!="list"){
      close(pb)
      cat("Done.\n")
    }
    
    
    idx_annot_exist <-  which(N_annot>0);
    p_value_adjust_fdr <- rep( 1,length(p_value) );
    p_value_adjust_bonferroni <- rep( 1,length(p_value) );
    p_value_adjust_bonferroni[idx_annot_exist] <- p.adjust(p_value[idx_annot_exist], method = "bonferroni");
    p_value_adjust_fdr[idx_annot_exist] <- p.adjust(p_value[idx_annot_exist], method = "fdr");
    
    df.annot.set <- data.frame(
      N_annot,
      freq_annot,
      fold_change, 
      p_value, 
      p_value_adjust_fdr,
      nodes_annot,
      p_value_adjust_bonferroni,
      N_annot_background, 
      freq_annot_background,
      nodes_annot_background)
    
    df.annot.set <- cbind(df.annot, df.annot.set)
    
    if (orderOutput) df.annot.set <- df.annot.set[ order(df.annot.set$p_value, decreasing = FALSE), ]

    df.annot.tot[[i]] <- df.annot.set
    
  }
  
  if (showProgress & typeof(idx_detect)=="list") close(pb)
  
  if (typeof(idx_detect)=="list"){
    return(df.annot.tot)
  } else {
    return(df.annot.tot[[1]])
  }
  
}

#' @export
plot_annotation_results <- function(df, p_val_max=0.05, method_adjust_p_val = "fdr", fold_change_min =2, N_annot_min=2){
  
  if(length(df) == 0 ){
    warning("Empty input...")
  }else if( dim(df)[1] == 0){
    warning("Empty input...")
  }
    
  name_p_val <- switch(method_adjust_p_val,
                       "none" = "p_value",
                       "fdr" = "p_value_adjust_fdr",
                       "bonferroni" = "p_value_adjust_bonferroni")
  
  df$p_value_adjusted <- df[[name_p_val]]
  
  idx_filter <-  which(df$p_value_adjusted <= p_val_max & 
                       df$fold_change >= fold_change_min & 
                       df$N_annot >= N_annot_min)
  if(length(idx_filter) == 0){
    warning("No annotation left after filtering. You might want to change input parameters")
    return(NULL)
  }
  df_filter <- df[ idx_filter, ]
  df_filter <- df_filter[ order(df_filter$p_value, decreasing = TRUE), ]
  df_filter$order <- 1:dim(df_filter)[1]
  
  p <- ggplot( df_filter, aes(x=order, y=-log10(p_value_adjusted) )) + 
    theme(
      axis.text.y = element_text(size=14),
      axis.text.x = element_text(size=14, angle = 90, hjust = 1,vjust=0.5),
      axis.title.x = element_text(size=14)
    ) +
    scale_x_continuous(name = NULL, breaks=df_filter$order, labels=df_filter$annot_names) +
    scale_y_continuous(name = paste("-log10(",name_p_val,")",sep="")) +
    geom_col()+
    coord_flip()
  
  return(p)
  
}

#' @export
append_annotations <- function (x, ...) {
  UseMethod("append_annotations", x)
}

#' @export
append_annotations.InteRactome <- function( res, annotations=NULL, name_id = "Protein.IDs" ){
  
    res_int<-res
    
    n_annot <- 0
    for (annot_var in names(annotations)){
      n_annot <- n_annot + length(annotations[[annot_var]])
    }
    
    if( is.null(annotations) | n_annot == 0){
      warning("No annotations to append")
    }
    else{
      cat("Append annotation to interactome...\n")
      idx_match<-rep(NA,length(res$names))
      for(i in 1:length(res$names) ){
        idx_match[i] <- which(as.character(annotations[[name_id]]) == as.character(res[[name_id]][i]) )
      }
      
      for( var_names in setdiff(names(annotations), name_id) ){
        res_int[[var_names]] <- as.character(annotations[[var_names]][idx_match])
      }
      cat("Done.\n")
    }
    
    return(res_int)
    
}

#' @export
get_annotations <- function( data, name_id = "Protein.IDs", split_param = ";", organism = "mouse", updateProgress = NULL ){
# Get annotations from uniprot for a set of protein identifiers
# From a set of IDs, keep the first that correspond to a "reviewed" protein, 
# or by default the first ID of the set
# name_id : column containing the set of protein identifiers separated by "split_param"
# organism = c("mouse", "human")
  
  df_annot <- switch(organism, "mouse" = uniprot_data_mouse, "human" = uniprot_data_human)
  
  df<-NULL
  
  nodes_IDs<- as.character(data[[name_id]]);
  Nnodes<-length(nodes_IDs)
  
  if( length( strsplit( paste(nodes_IDs, collapse=" "), split = split_param, fixed = TRUE)[[1]] ) == 1){
    warning(paste("The split parameter '",split_param, "' was not detected in '", name_id,"' : you might need to change 'split_param'.", sep = "") )
  }
    
  nodes_ID<-rep("", Nnodes);
  imatch<-rep(NA, Nnodes);
  

  # create progress bar
  cat("Creating annotation table...\n")
  pb <- txtProgressBar(min = 0, max = Nnodes, style = 3)
  
  
  for (i in 1:Nnodes ){
    
    list_nodes_ID<- unique(strsplit(nodes_IDs[i], split=split_param, fixed = TRUE)[[1]]);
    for(j in 1:length(list_nodes_ID) ){
      nID_clean <- strsplit(list_nodes_ID[j], split="-")[[1]][1];
      idx_entry<-which(df_annot$Entry == nID_clean)
      if(length(idx_entry>0)) {
        
        if(is.na(imatch[i])){
          imatch[i]<-idx_entry;
        }
        
        if(df_annot$Status[idx_entry]=="reviewed"){
          imatch[i]<-idx_entry;
          break;
        }
        
      }
    }
    setTxtProgressBar(pb, i)
    
    if (is.function(updateProgress)) {
      text <- paste0( round(i/Nnodes*100, 0), " %")
      updateProgress(value = i/Nnodes*100, detail = text)
    }
    
  }
  close(pb)
  
  df<-df_annot[imatch, ]
  df <- cbind(data[[name_id]], df)
  names(df)[1] <- name_id
  
  names(df)[which(names(df) == "Cross.reference..Pfam.")]<-"Pfam"
  names(df)[which(names(df) == "Cross.reference..Reactome.")]<-"Reactome"
  names(df)[which(names(df) == "Gene.ontology..GO.")]<-"GO"
  
  cat("Done.\n")
  
  return(df)
  
}

#' @export
add_GO_data <- function(df, map_id = "Entry", GO_type="molecular_function", organism = "mouse", slim = FALSE, updateProgress = NULL){
# GO_type = "molecular_function", biological_process" or "cellular_component"
# organism = "mouse" or "human
# slim = TRUE or FALSE (use GO slim annotations)
  
  df_int <- df
  n <- length(df_int[[map_id]])
  
  GO_terms <- rep("", n)
  
  name_GOA <- paste("GOA_", organism, sep = "");
  if (slim) {
    name_GOA <- paste(name_GOA, "_slim", sep = "")
  }
  GOA <- get(name_GOA)
  
  idx_type <- as.vector(which(GOA$GO_type == GO_type))
  
  # create progress bar
  cat("Add GO annotation data...\n")
  pb <- txtProgressBar(min = 0, max = n, style = 3)
  
  for(i in 1:n){
    # progress bar
    if (is.function(updateProgress)) {
      text <- paste0( round(i/n*100, 0), " %")
      updateProgress(value = i/n*100, detail = text)
    }
    setTxtProgressBar(pb, i)
    
    idx_GO <- idx_type[ grep(df_int[[map_id]][i], GOA$DB_Object_ID[idx_type], fixed = TRUE) ]
    if(length(idx_GO) > 0){
      term <- paste(GOA$GO_name[idx_GO], " [", GOA$GO_ID[idx_GO], "]", sep = "")
      GO_terms[i] <- paste(as.character(unique(term)), collapse = ";")
    }
    
  }
  close(pb)
  
  name_annot <- "GO_"
  if( slim ) name_annot <- paste(name_annot, "slim_", sep ="")
  name_annot <- paste(name_annot, GO_type, sep= "")
  df_int[[name_annot]] <- GO_terms
  
  return(df_int)
}

#' @export
add_KEGG_data <- function(df, map_id = "Cross.reference..KEGG.", organism="mouse", updateProgress = NULL){
  
  df_int <- df
  n <- length(df_int[[map_id]])
  
  # Add KEGG data
  KEGG_pathways <- rep("", n)
  KEGG <- switch(organism, "mouse" = KEGG_mouse, "human" = KEGG_human)
  for(i in 1:n){
    # progress bar
    if (is.function(updateProgress)) {
      text <- paste0( round(i/n*100, 0), " %")
      updateProgress(value = i/n*100, detail = text)
    }
    
    if(!is.na(df_int[[map_id]][i])){
      if( nchar(as.character(df_int[[map_id]][i])) >0 ){
        idx_KEGG <- grep(df_int[[map_id]][i], as.character(KEGG$IDs), fixed = TRUE)
        pathways <- paste(KEGG$name[idx_KEGG]," [",KEGG$pathway[idx_KEGG],"]",sep="")
        KEGG_pathways[i] <- paste(as.character(pathways), collapse = ";")
      }
    }
    
  }
  df_int$KEGG <- KEGG_pathways
  
  return(df_int)
}

#' @export
add_Hallmark_data <- function(df, map_id="Gene.names...primary..", updateProgress = NULL){
  
  df_int <- df
  
  n <- length(df_int[[map_id]])
  hallmark_set <- rep("", n )
  
  
  # create progress bar
  cat("Add Hallmark annotation data...\n")
  pb <- txtProgressBar(min = 0, max = n, style = 3)
  
  for(i in 1:n){
    # progress bar
    if (is.function(updateProgress)) {
      text <- paste0( round(i/n*100, 0), " %")
      updateProgress(value = i/n*100, detail = text)
    }
    setTxtProgressBar(pb, i)
    idx_set <- NULL
    for(j in 1:dim(Hallmark)[1]){
      idx_in_geneset <- match(toupper(df_int[[map_id]][i]), strsplit(as.character(Hallmark$gene[j]), split=";")[[1]])
      if(!is.na(idx_in_geneset)){
        idx_set <- c(idx_set, j)
      }
    }
    hallmark_set[i] <- paste( as.character(Hallmark$name[idx_set]), collapse=";")
  }
  close(pb)
  
  df_int$Hallmark <- hallmark_set
  
  return(df_int)
}

#' @export
merge_proteome <- function (x, ...) {
  UseMethod("merge_proteome", x)
}

#' @export
merge_proteome.InteRactome <- function( res, Interactome_ID_name = "Entry" ){
  
      res_int <- res;
    
      gene_name_prot <- proteome_data$Gene.names;
    
      ibait <- match(res$bait, res$names)
      
      ######### Retrieve protein abundance and compute related quantities
      
      Copy_Number <- rep(0, length(res$names));
    
      for( i in 1:length(res$names) ){
        idx_prot <- which(gene_name_prot==as.character(res$names[i]));
        idx_ID_x <-  which(proteome_data$Protein.IDs.x==as.character(res$Protein.IDs[i]));
        idx_ID_y <-  which(proteome_data$Protein.IDs.y==as.character(res$Protein.IDs[i]));
        
        #idx_ID_x <-  grep(as.character(res[[Interactome_ID_name]][i]),  as.character(proteome_data$Protein.IDs.x), fixed=TRUE);
        #idx_ID_y <-  grep(as.character(res[[Interactome_ID_name]][i]),  as.character(proteome_data$Protein.IDs.y), fixed=TRUE);
        # 
        abund_x <- NA;
        abund_y <- NA;
        if( length(idx_ID_x)>0 ){ 
          abund_x <- proteome_data$mean.x[idx_ID_x] 
        }
        if( length(idx_ID_y)>0 ){ 
          abund_y <- proteome_data$mean.y[idx_ID_y] 
        }
        
        #Copy_Number[i] <- mean(c(abund_x, abund_y), na.rm = TRUE)
        
        if(length(idx_prot)>0){
         Copy_Number[i] = proteome_data$mean[ idx_prot[1] ];
        }else if( length(idx_ID_x)>0 || length(idx_ID_y)>0 ){
         Copy_Number[i] = mean( c(abund_x, abund_y), na.rm=TRUE);
        }else{
         Copy_Number[i] = NA;
        }
        
      }
      res_int$Copy_Number = Copy_Number
      res_int$stoch_abundance = Copy_Number / Copy_Number[ibait]
      
      #res_int$N_complex= Tsum$max_stoch*Copy_Number[ibait]
      #res_int$percentage_prey_in_complex = Tsum$max_stoch*Copy_Number[ibait]/Copy_Number;
      
      # Tsum$Perc_t_0 = Tsum$Stoch_t_0*Copy_Number[ibait]/Copy_Number;
      # Tsum$Perc_t_30 = Tsum$Stoch_t_30*Copy_Number[ibait]/Copy_Number;
      # Tsum$Perc_t_120 = Tsum$Stoch_t_120*Copy_Number[ibait]/Copy_Number;
      # Tsum$Perc_t_300 = Tsum$Stoch_t_300*Copy_Number[ibait]/Copy_Number;
      # Tsum$Perc_t_600 = Tsum$Stoch_t_600*Copy_Number[ibait]/Copy_Number;
  
      output=res_int
}

#' @export
plot_2D_stoichio <- function (x, ...) {
  UseMethod("plot_2D_stoichio", x)
}

#' @export
plot_2D_stoichio.InteRactome <- function( res, condition = "max", xlim=NULL, ylim=NULL, N_display=30){
  
  df<- data.frame( Y=log10(res$stoch_abundance), 
                   label_tot=res$names
                   )
  if(condition=="max"){
    df$X <- log10(res$max_stoichio)
    df$size <- res$max_fold_change
  }else if(condition %in% res$conditions){
    df$X <- log10(res$stoichio[[condition]])
    df$size <- res$fold_change[[condition]]
  }else{
    stop("Condition is not defined")
  }
  
  
  df<-df[1:min(N_display, dim(df)[1]), ]
  
  xc <- -0.5
  yc <- 0
  rc<-1
  
  ylow <- -3
  
  if(is.null(xlim) & is.null(ylim)){
    max_range <- max( max(df$X,na.rm=TRUE)-min(df$X,na.rm=TRUE),  max(df$Y,na.rm=TRUE)-ylow )
    center_x <- ( max(df$X,na.rm=TRUE)+min(df$X,na.rm=TRUE) )/2
    center_y <- (max(df$Y,na.rm=TRUE)+ylow)/2
  }else{
    max_range <- max( xlim[2] - xlim[1],  ylim[2] - ylim[1] )
    center_x <- ( xlim[2] + xlim[1] )/2
    center_y <- ( ylim[2] + ylim[1] )/2
  }
  xmin<-center_x - max_range/1.9
  xmax<-center_x + max_range/1.9
  ymin<-center_y - max_range/1.9
  ymax<-center_y + max_range/1.9
  
  ylow_plot <- max(ylow,ymin)
  
  df$size_prey <- log10(df$size)/max_range*20
  df$size_label <- unlist(lapply(log10(df$size), function(x) { ifelse(x>0.5, min(c(x,3)), 0.5) }))/max_range*20/3
  df$sat_max_fold_t0 <- rep(1,dim(df)[1])
  
  idx_plot <- which(df$X<=xmax & df$X>=xmin & df$Y<=ymax & df$Y>=ymin)
  df <- df[idx_plot, ]
  
  p<-ggplot(df,aes(x=X, y=Y,label=label_tot)) +
    theme(aspect.ratio=1) +
    scale_color_gradient2(midpoint=0,  low="blue", mid=rgb(0,0,0), high="red",  space = "Lab" )+
    geom_polygon(data=data.frame(x=c(ylow_plot,xmax,xmax),y=c(ylow_plot,ylow_plot,xmax)), mapping=aes(x=x, y=y),alpha=0.1,inherit.aes=FALSE) +
    annotate("path",
             x=xc+rc*cos(seq(0,2*pi,length.out=100)),
             y=yc+rc*sin(seq(0,2*pi,length.out=100)), color=rgb(0,0,0,0.5) ) +
    annotate("segment", x = ylow_plot, xend = xmax, y = ylow_plot, yend = xmax, colour = rgb(0,0,0,0.5) ) +
    annotate("segment", x = xmin, xend = xmax, y = ylow_plot, yend = ylow_plot, colour = rgb(0,0,0,0.5) , linetype = "dashed") +
    xlab("log10(Interaction Stoichiometry)") +
    ylab("log10(Abundance Stoichiometry)") +
    geom_point(mapping=aes(x=df$X,y=df$Y,color=df$sat_max_fold_t0), size=df$size_prey, alpha=0.2, stroke=0, inherit.aes = FALSE, show.legend = FALSE)+
    coord_cartesian(xlim = c(xmin,xmax), ylim = c(ymin,ymax), expand = FALSE)+
    #geom_density_2d(colour=rgb(1,0,0),size=0.5) +
    geom_text_repel(mapping=aes(x=df$X,y=df$Y,label=label_tot,color=df$sat_max_fold_t0), size=df$size_label,force=0.002, 
                    segment.size = 0.1,
                    min.segment.length = unit(0.15, "lines"), 
                    point.padding = NA, inherit.aes = FALSE, show.legend = FALSE, max.iter = 100000)
  return(p)
  #print(p)
  #output=p
}

#' @export
identify_interactors <- function(res, 
                                var_p_val = "p_val", 
                                p_val_thresh = 0.05, 
                                fold_change_thresh = 2, 
                                n_success_min = 1, 
                                consecutive_success = FALSE){
  
  res_int <- res
  
  n_cond <- length(res$conditions)
  is_interactor <- rep(0, length(res$names))
  n_success <- rep(0, length(res$names))
  
  M <- do.call(cbind, res[[var_p_val]]) < p_val_thresh & do.call(cbind, res[["fold_change"]]) > fold_change_thresh
  
  for (i in 1:length(res$names)){
    
    M_test <- M[i, ]
    n_success[i] <- sum( M_test )
    
    if (consecutive_success & n_success_min > 1){
      for (k in 1:(n_success_min-1)){
        idx_mod <- ((1:n_cond) + k) %% n_cond
        idx_mod[ idx_mod == 0] <- n_cond
        M_test <- rbind(M_test, M[i, idx_mod])
      }
      is_interactor[i] <- sum( colMeans( M_test ) == 1 ) > 0
    } else {
      is_interactor[i] <- n_success[i] >= n_success_min
    }
    
  }
  
  res_int$is_interactor <- is_interactor
  res_int$n_success <- n_success
  res_int$interactor <- res$names[is_interactor>0]
  
  return(res_int)
  
}

#' @export
discretize_values <- function( x, breaks = c(1,0.1,0.05,0.01), decreasing_order = TRUE){
  
  breaks_order <- breaks[order(breaks, decreasing=decreasing_order)]
  
  x_discrete <- rep(NA, length(x));
  
  for( i in 1:length(breaks_order) ){
    x_discrete[ x <= breaks_order[i] ] <- breaks_order[i];
  }
  
  return(x_discrete)
}

#' @export
get_order_discrete <- function (x, ...) {
  UseMethod("get_order_discrete", x)
}

#' @export
get_order_discrete.InteRactome <- function( res, var_p_val = "min_p_val", p_val_breaks=c(1,0.1,0.05,0.01)){
  
  min_p_val_discrete <- discretize_values(res[[var_p_val]], breaks = p_val_breaks, decreasing_order = TRUE)
  
  if( "interactor" %in% names(res)){
    Ndetect<-length(res$interactor)
    idx_order<-order(res$is_interactor, res$n_success, 1/min_p_val_discrete, res$max_stoichio, decreasing = TRUE)
  } else {
    Ndetect<-length(which(min_p_val_discrete<=0.05))
    idx_order<-order(1/min_p_val_discrete, res$max_stoichio, decreasing = TRUE)
  }
  
  output = list(idx_order=idx_order, Ndetect= Ndetect, min_p_val_discrete = min_p_val_discrete)
  
  return(output)
}

#' @export
order_interactome <- function (x, ...) {
  UseMethod("order_interactome", x)
}

#' @export
order_interactome.InteRactome <- function(res, idx_order){
  
  if(length(idx_order)!=length(res$names)){
    stop("Vector of ordering indexes does not have the proper length")
  }
  res_order<-res;
  for( var in setdiff( names(res), c("bait","groups","conditions", "interactor", "replicates") ) ){
    
    if(length(res[[var]]) == length(res$names)){
      res_order[[var]] <- res[[var]][idx_order]
    }
    else{
      names_var <- names(res[[var]])
      if( setequal(names_var, res$conditions) ){
        for(i in 1:length(names_var) ){
          res_order[[var]][[i]] <- res[[var]][[i]][idx_order]
        }
      }
      else{
        for(i in 1:length(names_var) ){
          names_var_2 <- names(res[[var]][[i]]) 
          if( setequal(names_var_2, res$conditions) ){
            for(j in 1:length(names_var_2) ){
              res_order[[var]][[i]][[j]] <- res[[var]][[i]][[j]][idx_order]
            }
          }
        }
      }
    }
    
  }
  output = res_order
}

#' @export
plot_Intensity_histogram <- function( I, I_rep, breaks=20, save_file=NULL){
    # plot histogram of intensities for all columns in two different datasets 
    # (1st dataset is in in black, 2nd dataset is in red)
    if(!is.null(save_file)){
      pdf( save_file, 4, 4 )
    }
    
    
    for( j in seq_along(I) ){
      h<-hist( I[[j]] , breaks=breaks, plot=FALSE);
      if(j>1){
        lines(h$mids,h$density,col=rgb(0,0,0,0.2));
      }else{
        plot(h$mids, h$density, type="l",col=rgb(0,0,0,0.2),ylim=c(0,1), xlim=range(I_rep));
      }
    }
    
    for( j in seq_along(I_rep) ){
      h<-hist( I_rep[[j]] , breaks=breaks, plot=FALSE);
      lines(h$mids,h$density,col=rgb(1,0,0,0.2));
    }
    
    if(!is.null(save_file)){
      dev.off()
    }
  
}

#' @export
plot_volcanos <- function (x, ...) {
  UseMethod("plot_volcanos", x)
}

#' @export
plot_volcanos.InteRactome <- function( res, 
                                       labels=NULL, 
                                       N_print=15, 
                                       conditions=NULL, 
                                       p_val_thresh=0.05, 
                                       fold_change_thresh=2, 
                                       save_file=NULL,
                                       xlim=NULL,
                                       ylim=NULL,
                                       show_plot=FALSE,
                                       asinh_transform = TRUE){
  if (is.null(labels)) labels=res$names
  if (is.null(conditions)) conditions=res$conditions
    
  plist <- vector("list",length(conditions));
  
  ymax <- -log10(min(do.call(cbind,res$p_val)))
  if (asinh_transform) ymax <- asinh(ymax)
  xmax <- max(abs(log10(do.call(cbind,res$fold_change))))
  
  x1 <- log10(fold_change_thresh)
  x2 <- xmax
  y1 <- -log10(p_val_thresh)
  if (asinh_transform) y1 <- asinh(y1)
  y2 <- ymax
  
  
  if(!is.null(xlim) ){
    xrange <- xlim
  }else{
    xrange <- c(-xmax,xmax)
  }
  
  if(!is.null(ylim)){
    yrange <- ylim
  }else{
    yrange <- c(0,ymax)
  }
  
  for( i in seq_along(conditions) ){
    
    df <- data.frame(p_val=res$p_val[[conditions[i]]], 
                     fold_change= res$fold_change[[conditions[i]]], 
                     names=labels)
    df$X <- log10(df$fold_change)
    df$Y <- -log10(df$p_val)
    if (asinh_transform) df$Y <- asinh(df$Y)
    score_print <- rep(0, dim(df)[1])
    
    if(!is.null(p_val_thresh) & !is.null(fold_change_thresh)){
      is_above_thresh <- rep(0, dim(df)[1])
      is_in_frame <- rep(0, dim(df)[1])
      is_above_thresh[ which(df$p_val <= p_val_thresh & df$fold_change >= fold_change_thresh ) ] <- 1
      is_in_frame[ which(df$X >= xrange[1] & df$X <= xrange[2] & df$Y >= yrange[1] & df$Y <= yrange[2]) ] <- 1
      score_print<- is_above_thresh + is_in_frame
      score_print[is_in_frame==0]<-0
      N_show <- min(N_print, sum(score_print>0))
      if( N_show>0 ){
        idx_print <- order(score_print, df$fold_change, decreasing = TRUE)[ 1 : N_show ]
      }else{
        idx_print <- NULL
      }
    }else{
      if( N_print>0 ){
        idx_print <- order(df$fold_change, decreasing = TRUE)[ 1:N_print ]
      }else{
        idx_print <- NULL
      }
    }
    
    df$label_color <- as.factor(score_print)
    
    label_x <- "log10(fold_change)"
    label_y <- "-log10(p_value)"
    if (asinh_transform) label_y <- "asinh(-log10(p_value))"
      
    plist[[i]] <- ggplot( df , aes(x=X, y=Y ) ) +
      coord_cartesian(xlim = xrange, ylim = yrange, expand = FALSE) +
      xlab(label_x ) + 
      ylab(label_y) + 
      #scale_y_continuous(limits=c(0,ymax)) +
      #scale_x_continuous(limits=c(-xmax,xmax)) +
      ggtitle(conditions[i])
      
    
    if(!is.null(p_val_thresh) & !is.null(fold_change_thresh)){
      plist[[i]] <- plist[[i]] +
        geom_polygon(data=data.frame(x=c(x1,x2,x2,x1),y=c(y1,y1,y2,y2)), mapping=aes(x=x, y=y),alpha=0.1,inherit.aes=FALSE) +
        annotate("segment", x = -x2, xend = x2, y = y1, yend = y1, colour = rgb(1,0,0,0.5) ) +
        annotate("segment", x = -x1, xend = -x1, y = 0, yend = y2, colour = rgb(1,0,0,0.5) ) +
        annotate("segment", x = x1, xend = x1, y = 0, yend = y2, colour = rgb(1,0,0,0.5) )
    }
    
    plist[[i]] <- plist[[i]] + 
      geom_point(alpha=0.2) +
      geom_text_repel(data=df[idx_print, ],
                      aes(label = names, colour=label_color), size=5) +
      scale_color_manual(values = c("0" = "black", "1" = "black", "2" = "red"), guide=FALSE) +
      theme(legend.position="none")
    
  }
  
  if(show_plot){
    layout <- matrix(1:length(conditions), nrow = 1, byrow = TRUE)
    multiplot(plotlist = plist, layout = layout)
  }
  if( length(save_file)>0 ){
    pdf( save_file, 4*length(conditions), 4 )
    layout <- matrix(1:length(conditions), nrow = 1, byrow = TRUE)
    multiplot(plotlist = plist, layout = layout)
    dev.off()
  }
  
  return(plist)
}

#' @export
plot <- function (x, ...) {
  UseMethod("plot", x)
}

#' @export
plot.InteRactome <- function(x, 
                             p_val_breaks=c(1,0.1,0.05,0.01), 
                             p_val_thresh = 0.01,
                             fold_change_thresh=2,
                             Nmax = 30, 
                             var_p_val = "min_p_val",
                             color_var = "p_val",
                             size_var="norm_stoichio", 
                             size_range=c(0,1), 
                             save_file=NULL,
                             clustering = FALSE){
  order_list <- get_order_discrete(x, 
                                   var_p_val = var_p_val, 
                                   p_val_breaks = p_val_breaks )
  Interactome_order <- order_interactome(x, order_list$idx_order)
  plot_per_conditions(Interactome_order, 
                      idx_rows = min(Nmax, order_list$Ndetect), 
                      size_var = size_var, 
                      size_range = size_range, 
                      color_var = color_var, 
                      color_breaks = p_val_breaks, 
                      save_file = save_file,
                      clustering = clustering)
}

#' @export
plot_per_conditions <- function (x, ...) {
  UseMethod("plot_per_conditions", x)
}

#' @export
plot_per_conditions.InteRactome <- function( res, 
                                 idx_rows=1:20,
                                 size_var="norm_stoichio",
                                 size_range=c(0,1),
                                 color_var="p_val", 
                                 color_breaks=c(1,0.1,0.05,0.01), 
                                 #color_values=rgb(t(col2rgb(c("black", "blue","purple","red")))/255),
                                 color_default = 1,
                                 save_file=NULL,
                                 show_plot=TRUE,
                                 plot_width=2.5 + length(res$conditions)/5,
                                 plot_height=2 + length(idx_rows)/5,
                                 clustering = TRUE){
  
  if(length(idx_rows)==1){
    idx_rows<-1:idx_rows
  }
  
  M<-do.call(cbind, res[[size_var]])
  M1<-do.call(cbind, res[[color_var]])
    
  row.names(M) <- unlist(lapply(res$names, function(x) substr(x,1,min(8,nchar(x))) ) )
  Mcol<-M
  Mcol[!is.null(M)]<-color_default
  
   if(!is.null(color_var)){
     idx_order_col <- order(color_breaks, decreasing = TRUE);
     for(i in seq_along(color_breaks)){
       Mcol[M1<color_breaks[idx_order_col[i]]]<-color_breaks[idx_order_col[i]]
     }
   }
  
  if("interactor" %in% names(res)){
    title_text <- paste(res$groups," (n=",length(res$interactor),")",sep="")
  } else {
    title_text <- res$groups
  }
  
  M <- M[idx_rows, ]
  Mcol <- Mcol[idx_rows, ]
  
  if(clustering){
    M[is.na(M)]<-0
    d<-dist(M)
    h<-hclust(d)
    M <- M[h$order, ]
    Mcol <- Mcol[h$order, ]
  } 
  
  p<-dot_plot( as.matrix(M), 
               as.matrix(Mcol), 
               title = title_text,
               size_var = size_var, 
               size_range=size_range,
               color_var=color_var)
  
  if(show_plot){
    print(p)
  }
  
  if(!is.null(save_file)){
    pdf(save_file, plot_width, plot_height)
    print(p)
    dev.off()
  }
  
  return(p)
  
}

#' @export
dot_plot <- function(Dot_Size, 
                     Dot_Color=NULL, 
                     title="Dot Plot", 
                     size_range=range(Dot_Size) , 
                     size_var ="size", 
                     color_var="color"){

  # Dot_Size: matrix of dot size
  
  M<-Dot_Size
  Mcol <- Dot_Color
  
  ylabels <- row.names(M)
  if(length(ylabels)==0){
    ylabels <- 1:dim(M)[1]
  }
  
  xlabels <- colnames(M)
  if(length(xlabels)==0){
    xlabels <- 1:dim(M)[2]
  }
  
  xpos <- vector("list", dim(M)[2] );
  ypos <- vector("list", dim(M)[2] );
  size <- vector("list", dim(M)[2] );
  if(length(Dot_Color)>0){
    if( sum(dim(M) != dim(M))==0 ){
      color <- vector("list", dim(M)[2] );
    }else{
      stop("Dimensions of size and color matrix do not match")
    }
  }
  
  #pos <- 1+dim(M)[1] - ( 1:dim(M)[1] )
  pos <-  - ( 1:dim(M)[1] )
  
  for( k in 1:dim(M)[2] ){
    xpos[[k]] <- rep(k, dim(M)[1] )
    ypos[[k]] <- pos
    size[[k]] <- as.numeric(M[,k]);
    if(length(Dot_Color)>0){
      color[[k]] <- Mcol[,k];
    }
  }
  
  df<-data.frame( xpos=unlist(xpos), ypos=unlist(ypos), size=unlist(size) );
  if(length(Dot_Color)>0){
    df$color = unlist(color)
  }else{
    df$color = rep( 1, dim(df)[1] )
  }
  
  df$color<-as.factor(df$color)
  
  unique_col <- unique(df$color);
  size_label_y <- max(6, 16 - (dim(M)[1] %/% 10)*1.5 )
  size_label_x <- max(6, 16 - (dim(M)[2] %/% 5)*1.5 )
  
  p <- ggplot(df, aes(x=xpos, y=ypos, size=size, col=color ) ) +
    theme(#plot.margin=unit(c(0.2,0,0,0), "cm"),
      plot.title = element_text(size=12),
      axis.text.y= element_text(size=size_label_y), 
      axis.text.x = element_text(size=size_label_x, angle = 90, hjust = 1,vjust=0.5) ) +
    ggtitle(title)+
    scale_color_manual( values=c( "red", "purple",  "blue", "black" ) , name=color_var) +
    scale_radius(limits=size_range, name=size_var) +
    #scale_colour_manual(values=setNames(unique_col, c( "red", "purple",  "blue", "black" ) )) +
    xlab("") +
    ylab("") +
    scale_x_continuous(breaks=1:dim(M)[2],
                       limits=c(0.5, dim(M)[2]+0.5),
                       labels=xlabels) +
    scale_y_continuous(breaks=pos,
                       #limits= -c(0.25, dim(M)[1]+0.75),
                       limits= -c(dim(M)[1]+0.75, 0.25 ),
                       labels=ylabels) +
    geom_point(alpha=0.5, show.legend = TRUE)
  
  return(p)
  
}

#' @export
summary_table <- function (x, ...) {
  UseMethod("summary_table", x)
}

#' @export
summary_table.InteRactome <- function(res, add_columns = names(res) ){
  
  columns <- unique( c("names", add_columns) )
  #columns <- add_columns
  columns <- setdiff(columns, c("bait","groups","conditions", "interactor", "replicates"))
  
  df<-data.frame( bait=rep(res$bait, length(res$names)) )
  names_df<-"bait"
  idx<-1
  
  for( var in columns ){
    
    if(length(res[[var]]) == length(res$names)){
      idx<-c(idx,1)
      names_df<-c(names_df, var)
      df<-cbind(df,res[[var]])
    }
    else{
      names_var <- names(res[[var]])
      if( setequal(names_var, res$conditions) ){
        for(i in 1:length(names_var) ){
          idx<-c(idx,NaN)
          names_df<-c(names_df, paste(var,"_",names_var[i],sep=""))
          df<-cbind(df,res[[var]][[i]])
        }
      }
      else{
        for(i in 1:length(names_var) ){
          names_var_2 <- names(res[[var]][[i]]) 
          if( setequal(names_var_2, res$conditions) ){
            for(j in 1:length(names_var_2) ){
              idx<-c(idx,NaN)
              names_df<-c(names_df, paste(var,"_",names(res[[var]])[i],"_",names_var_2[j],sep=""))
              df<-cbind(df,res[[var]][[i]][[j]])
            }
          }
        }
      }
    }
    
  }
  
  names(df)<-names_df
  df<-df[,order(idx)]
  
  return(df)
  
}

#' @export
compute_correlations <- function (x, ...) {
  UseMethod("compute_correlations", x)
}

#' @export
compute_correlations.InteRactome <- function(res, idx = NULL){
  
  # build matrix on which correlations will be computed
  idx_selected <- 1:length(res$names)
  if (!is.null(idx)) {
    idx_selected <- idx
  }
  idx_bait <- which(res$names == res$bait)
  idx_selected <- setdiff(idx_selected, idx_bait)
  
  names <- res$names[idx_selected]
  
  df<-NULL
  names_df <- NULL
  for (bio in res$replicates){
    for (cond in res$conditions){
      df <- cbind(df, res$stoichio_bio[[bio]][[cond]][idx_selected])
      names_df <- c(names_df, paste("stoichio_bio_",bio,"_",cond,sep=""))
    }
  }
  
  for (i in dim(df)[1]){
    df[i, ] <- df[i, ]/max(df[i, ], na.rm=TRUE)
  }
  
  M <- as.matrix(df)
  row.names(M) <- names
  colnames(M) <- names_df
  
  
  R <- rcorr(t(M))
  n <- dim(R$r)[1]
  r_corr <- rep(NA, n*(n-1)/2)
  p_corr <- rep(NA, n*(n-1)/2)
  name_1 <- rep("", n*(n-1)/2)
  name_2 <- rep("", n*(n-1)/2)
  count<-0
  for (i in 1:(n-1)){
    for (j in (i+1):n){
      count<-count+1
      r_corr[count] <- R$r[i, j]
      p_corr[count] <- R$P[i, j]
      name_1[count] <- names[i]
      name_2[count] <- names[j]
    }
  }
  df_corr <- data.frame( name_1 = name_1, name_2 = name_2, r_corr = r_corr, p_corr = p_corr)
  
  return(df_corr)
}

#' @export
plot_correlation_network <- function(df_corr, r_corr_thresh = 0.8, p_val_thresh = 0.05){
  
  df_corr_filtered <- df_corr[df_corr$r_corr>=r_corr_thresh & df_corr$p_corr<=p_val_thresh, ]
  
  net <- graph.data.frame(df_corr_filtered, directed=FALSE);
  net.s<-igraph::simplify(net)
  cfg <- cluster_fast_greedy(as.undirected(net.s))
  
  #plot(cfg, as.undirected(net.s))
  plot(as.undirected(net.s), mark.groups = communities(cfg))
}

#' @export
get_PPI_from_psicquic <- function( gene_name, tax_ID = c(9606,10090) , provider = c("IntAct","MINT") ){
  
  library(PSICQUIC)
  psicquic <- PSICQUIC()
  
  for (k in 1:length(tax_ID) ){
    
    tbl <- interactions(psicquic, 
                        gene_name, 
                        species = tax_ID[k] , 
                        provider = provider )
    
    s<-strsplit(tbl$aliasA, split="|", fixed = TRUE);
    gene_name_A <- rep("",length(s))
    if(length(s)>0){
      for (i in 1:length(s) ){
        ign<-grep("(gene name)",s[[i]],fixed=TRUE)
        if(length(ign)>0){
          gene_name_A[i] <- strsplit( strsplit(s[[i]][ign],split=":")[[1]][2], 
                                      split="(" ,fixed=TRUE )[[1]][1]
          
        }
      }
    }
    
    s<-strsplit(tbl$aliasB,split="|",fixed = TRUE);
    gene_name_B <- rep("",length(s))
    if(length(s)>0){
      for (i in 1:length(s) ){
        ign<-grep("(gene name)",s[[i]],fixed=TRUE)
        if(length(ign)>0){
          gene_name_B[i] <- strsplit( strsplit(s[[i]][ign],split=":")[[1]][2], 
                                      split="(" ,fixed=TRUE )[[1]][1]
        }
      }
    }
    
    s<-strsplit(tbl$A,split = ":")
    uniprot_A <- rep("",length(s))
    if(length(s)>0){
      for (i in 1:length(s) ){
        uniprot_A[i] <- s[[i]][2]
      }
    }
    
    s<-strsplit(tbl$B,split = ":")
    uniprot_B <- rep("",length(s))
    if(length(s)>0){
      for (i in 1:length(s) ){
        uniprot_B[i] <- s[[i]][2]
      }
    }
    
    s<-strsplit(tbl$publicationID,split = "|",fixed=TRUE)
    Pubmed_ID <- rep("",length(s))
    if(length(s)>0){
      for (i in 1:length(s) ){
        ip<-grep("pubmed",s[[i]],fixed=TRUE);
        Pubmed_ID[i] <- strsplit(s[[i]][ip],split=":")[[1]][2];
      }
    }
    
    s<-strsplit(tbl$type,split = "(",fixed=TRUE)
    Int_type <- rep("",length(s))
    if(length(s)>0){
      for (i in 1:length(s) ){
        Int_type[i] <- strsplit(s[[i]][2],split=")",fixed=TRUE)[[1]][1];
      }
    }
    
    s<-strsplit(tbl$detectionMethod,split = "(",fixed=TRUE)
    Detection_method <- rep("",length(s))
    if(length(s)>0){
      for (i in 1:length(s) ){
        Detection_method[i] <- strsplit(s[[i]][2],split=")",fixed=TRUE)[[1]][1];
      }
    }
    
    s<-strsplit(tbl$firstAuthor,split = " ",fixed=TRUE)
    Author <- rep("",length(s))
    if(length(s)>0){
      for (i in 1:length(s) ){
        Author[i] <- paste(s[[i]][1], s[[i]][length(s[[i]])],sep=" ");
      }
    }
    
    taxon<-rep(tax_ID[k],length(s) );
    
    if(k>1){
      #df2<-data.frame(gene_name_A, gene_name_B, uniprot_A, uniprot_B, taxon, Int_type, Detection_method, Author=Author, pubmed_ID=pubmed_ID, Database=tbl$provider)
      df2<-data.frame(gene_name_A, gene_name_B, taxon, Int_type, 
                      Detection_method, Author=Author, Pubmed_ID=Pubmed_ID, Database=tbl$provider)
      df1<-rbind(df1,df2);
      
    }
    else{
      #df1<-data.frame(gene_name_A, gene_name_B, uniprot_A, uniprot_B, taxon, Int_type, Detection_method, Author=Author, pubmed_ID=pubmed_ID, Database=tbl$provider)
      df1<-data.frame(gene_name_A, gene_name_B, taxon, Int_type, 
                      Detection_method, Author=Author, Pubmed_ID=Pubmed_ID, Database=tbl$provider)
      
    }
    
    df1 <- df1[nchar(as.character(df1$gene_name_A))>0 & nchar(as.character(df1$gene_name_B))>0 , ]
    
  }
  
  return(df1)
}

#' @export
get_PPI_from_BioGRID <- function( gene_name, tax_ID = c(9606,10090) ){
  
  access_key <- "7ad36061b7644111aa9f5b3948429fb2"
  
  for (k in 1:length(tax_ID) ){
  
    url_adress <- paste("http://webservice.thebiogrid.org/interactions?searchNames=true&geneList=",
                        gene_name,"&includeInteractors=true&format=tab2&includeHeader=true&taxId=",
                        tax_ID[k],"&accesskey=",
                        access_key,sep="");
    
    Tbiogrid <- read.table(url_adress,header=TRUE,fill=TRUE,sep="\t",comment.char="", quote="\"")
    
    Tbiogrid <- Tbiogrid[Tbiogrid$Organism.Interactor.A == Tbiogrid$Organism.Interactor.B,]
    
    taxon_biogrid <- rep(tax_ID[k],dim(Tbiogrid)[1] );  
    
    s<-strsplit(as.character(Tbiogrid$Author),split = " ",fixed=TRUE)
    Author_Biogrid <- rep("",length(s))
    
    if(length(s)>0){
      for (i in 1:length(s) ){
        Author_Biogrid[i] <- paste(s[[i]][1], s[[i]][length(s[[i]])],sep=" ");
      }
    }
    
    
    
    if(k>1){
      df_biogrid_2 <- data.frame(gene_name_A=Tbiogrid$Official.Symbol.Interactor.A, 
                                 gene_name_B = Tbiogrid$Official.Symbol.Interactor.B, 
                                 taxon=taxon_biogrid, 
                                 Int_type=Tbiogrid$Experimental.System.Type, 
                                 Detection_method=Tbiogrid$Experimental.System, 
                                 Author=Author_Biogrid, 
                                 Pubmed_ID=Tbiogrid$Pubmed.ID,  
                                 Database=Tbiogrid$Source.Database )
      df_biogrid_1 <- rbind(df_biogrid_1,df_biogrid_2);
    }
    else{
      df_biogrid_1 <- data.frame(gene_name_A=Tbiogrid$Official.Symbol.Interactor.A, 
                                 gene_name_B = Tbiogrid$Official.Symbol.Interactor.B, 
                                 taxon=taxon_biogrid, 
                                 Int_type=Tbiogrid$Experimental.System.Type, 
                                 Detection_method=Tbiogrid$Experimental.System, 
                                 Author=Author_Biogrid, 
                                 Pubmed_ID=Tbiogrid$Pubmed.ID,  
                                 Database=Tbiogrid$Source.Database )
      
    }
    
  }
  
  return(df_biogrid_1)
  
}

#' @export
get_PPI_from_HPRD <- function( gene_name ){
    
    THPRD <- THPRD[which(THPRD$Gene_symbol_1 == toupper(gene_name) | THPRD$Gene_symbol_2 == toupper(gene_name)), ]
    
    df_HPRD <- data.frame(gene_name_A = THPRD$Gene_symbol_1, 
                          gene_name_B = THPRD$Gene_symbol_2, 
                          taxon = rep(9606, dim(THPRD)[1] ), 
                          Int_type = rep("NA", dim(THPRD)[1] ), 
                          Detection_method = THPRD$Experiment_type, 
                          Author = rep("NA", dim(THPRD)[1] ), 
                          Pubmed_ID = THPRD$Pubmed_id, 
                          Database = rep("HPRD", dim(THPRD)[1] ));
    return(df_HPRD)
  
}

#' @export
create_summary_table_PPI <- function(gene_name){
  
  cat("Fetching PPi from databases...\n")
  pb <- txtProgressBar(min = 0, max = 3, style = 3)
  
  df_psicquic <- get_PPI_from_psicquic(gene_name = gene_name)
  setTxtProgressBar(pb, 1)
  df_biogrid <- get_PPI_from_BioGRID(gene_name = gene_name)
  setTxtProgressBar(pb, 2)
  df_HPRD <- get_PPI_from_HPRD(gene_name = gene_name)
  setTxtProgressBar(pb, 3)
  close(pb)
  
  df_tot <- rbind(df_biogrid, df_psicquic, df_HPRD)
  
  uInteractors <- sort(unique(toupper(c(as.character(df_tot$gene_name_A), as.character(df_tot$gene_name_B) ) )))
  uInteractors <- uInteractors[ uInteractors != toupper(gene_name) ];
  
  N_pub_0 <- rep(0,length(uInteractors));
  Authors_0 <- rep("",length(uInteractors));
  Pubmed_ID_0 <- rep("",length(uInteractors));
  Detection_method_0 <- rep("",length(uInteractors));
  Int_type_0 <- rep("",length(uInteractors));
  Database_0 <- rep("",length(uInteractors));
  
  for (i in 1:length(uInteractors) ){
    
    i_int <- which( toupper(as.character(df_tot$gene_name_A)) == uInteractors[i] | toupper(as.character(df_tot$gene_name_B)) == uInteractors[i]  )
    
    Authors_0[i] <- paste(as.character(unique(df_tot$Author[i_int])), collapse="|")
    
    Pubmed_ID_0[i] <- paste(as.character(unique(df_tot$Pubmed_ID[i_int])), collapse=",")
    spl <- strsplit(Pubmed_ID_0[i], split=",");
    Pubmed_ID_0[i] <- paste(spl[[1]], collapse="|");
    N_pub_0[i] <- length(unique(spl[[1]]));
    
    #N_pub[idx_int] <- length(unique(df_tot$pubmed_ID[i_int]));
    
    Detection_method_0[i] <- paste(as.character(unique(df_tot$Detection_method[i_int])), collapse="|")
    Int_type_0[i] <- paste(as.character(unique(df_tot$Int_type[i_int])), collapse="|")
    Database_0[i] <- paste(as.character(unique(df_tot$Database[i_int])), collapse="|")
    
  }
  
  df_summary <-data.frame(gene_name_A=rep(toupper(gene_name),length(uInteractors)), 
                          gene_name_B=uInteractors, 
                          N_pub = N_pub_0, 
                          Authors = Authors_0, 
                          Pubmed_ID = Pubmed_ID_0,
                          Detection_method = Detection_method_0,
                          Int_type = Int_type_0,
                          Database= Database_0)
  
  return(df_summary)
}

#' @export
append_PPI <- function (x, ...) {
  UseMethod("append_PPI", x)
}

#' @export
append_PPI.InteRactome <- function( res, mapping = "names"){
  
  res_int <- res
  
  df_ppi <- create_summary_table_PPI( res$bait )
  uInteractors <- df_ppi$gene_name_B
  
  sh_preys<-intersect(toupper(res[[mapping]]), uInteractors)
  sh_preys<-setdiff(sh_preys, toupper(res$bait))
  
  N_pub <- rep(0,length(res$names));
  Authors <- rep("",length(res$names));
  Pubmed_ID <- rep("",length(res$names));
  Detection_method <- rep("",length(res$names));
  Int_type <- rep("",length(res$names));
  Database <- rep("",length(res$names));
  
  if(length(sh_preys)>0){
    
    for (i in 1:length(sh_preys) ){
      
      idx_int <- which(toupper(res[[mapping]]) == sh_preys[i] );
      i_int <- which( toupper(as.character(df_ppi$gene_name_A)) == sh_preys[i] | toupper(as.character(df_ppi$gene_name_B)) == sh_preys[i]  )
      
      Authors[idx_int] <- paste(as.character(unique(df_ppi$Authors[i_int])), collapse="|")
      
      Pubmed_ID[idx_int] <- paste(as.character(unique(df_ppi$Pubmed_ID[i_int])), collapse="|")
      spl <- strsplit(Pubmed_ID[idx_int], split="|", fixed=TRUE);
      
      N_pub[idx_int] <- length(unique(spl[[1]]));
      
      #N_pub[idx_int] <- length(unique(df_ppi$pubmed_ID[i_int]));
      
      Detection_method[idx_int] <- paste(as.character(unique(df_ppi$Detection_method[i_int])), collapse="|")
      Int_type[idx_int] <- paste(as.character(unique(df_ppi$Int_type[i_int])), collapse="|")
      Database[idx_int] <- paste(as.character(unique(df_ppi$Database[i_int])), collapse="|")
      
    }
    
  }
  
  res_int$N_pub <- N_pub
  res_int$Authors <- Authors
  res_int$Pubmed_ID <- Pubmed_ID
  res_int$Detection_method <- Detection_method
  res_int$Int_type <- Int_type
  res_int$Database <- Database
  
  return(res_int)
  
}